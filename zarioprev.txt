<codebase structure>
* app
   * manifests
   * kotlin+java
      * com.niyaz.zario
         * data
            * local
               * AppDatabase.kt
               * UsageStatDao.kt
               * UsageStatEntity.kt
            * model
               * AppBaselineInfo.kt
            * repository
               * StudyRepository.kt
               * StudyRepositoryImpl.kt
         * navigation
            * Screen.kt
         * services
            * UsageTrackingService.kt
         * ui
            * screens
               * AuthScreens.kt
               * MainScreen.kt
            * theme
               * Color.kt
               * Theme.kt
               * Type.kt
            * viewmodels
               * HomeViewModel.kt
         * utils
            * AppInfoHelper.kt
            * Constants.kt
            * PermissionsUtils.kt
            * StudyPhase.kt
            * StudyStateManager.kt
         * workers
            * DailyCheckWorker.kt
            * FirestoreSyncWorker.kt
         * MainActivity.kt
      * com.niyaz.zario (androidTest)
      * com.niyaz.zario (test)
   * java (generated)
   * res
      * values
         * strings.xml
   * res (generated)
* Gradle Scripts
   * build.gradle.kts (Project: Zario)
   * build.gradle.kts (Module :app)
   * proguard-rules.pro
   * gradle.properties
   * gradle-wrapper.properties
   * libs.versions.toml
   * local.properties
   * settings.gradle.kts
</codebase structure>
<AndroidManifest>
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:tools="http://schemas.android.com/tools">


   <!-- Permissions -->
   <uses-permission android:name="android.permission.INTERNET" />


   <!-- Special permission required to access app usage statistics -->
   <!-- Needs to be granted manually by the user in settings -->
   <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS"
       tools:ignore="ProtectedPermissions" />


   <!-- Required to post notifications on Android 13 (API 33) and above -->
   <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>


   <!-- Required to run services in the foreground (improves reliability for tracking) -->
   <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
   <!-- If targeting Android 14+, specify foreground service type -->
   <!-- <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC"/> -->


   <!-- Required to restart the tracking service when the device boots -->
   <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />


   <!-- Add near other permissions -->
   <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC"/>




   <application
       android:allowBackup="true"
       android:dataExtractionRules="@xml/data_extraction_rules"
       android:fullBackupContent="@xml/backup_rules"
       android:icon="@mipmap/ic_launcher"
       android:label="@string/app_name"
       android:roundIcon="@mipmap/ic_launcher_round"
       android:supportsRtl="true"
       tools:targetApi="31"> <!-- Consider updating targetApi to 33 or 34 if appropriate -->


       <!-- Declare the Main Activity -->
       <!-- This activity will launch when the user opens the app -->
       <!-- android:exported="true" allows it to be launched by the system launcher -->
       <activity
           android:name=".MainActivity"
           android:exported="true">
           <intent-filter>
               <action android:name="android.intent.action.MAIN" />
               <category android:name="android.intent.category.LAUNCHER" />
           </intent-filter>
       </activity>


       <!-- Declare the Usage Tracking Service -->
       <!-- Ensure the name matches your package and class name -->
       <service
           android:name=".services.UsageTrackingService"
           android:foregroundServiceType="dataSync"
           android:exported="false" />


       <!-- Use "dataSync" as it involves collecting local data. -->
       <!-- exported="false" means other apps cannot start this service. -->
       <!-- Consider adding android:permission="android.permission.BIND_JOB_SERVICE" if planning to use JobScheduler later -->


       <!-- Receiver to listen for device boot completion -->
       <!--
       <receiver
           android:name=".receivers.BootReceiver"
           android:enabled="true"
           android:exported="true">
           <intent-filter>
               <action android:name="android.intent.action.BOOT_COMPLETED"/>
           </intent-filter>
       </receiver>
       -->


   </application>


</manifest>


</AndroidManifest>


<AppDatabase>
package com.niyaz.zario.data.local


import android.content.Context
import android.util.Log
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration // Import Migration
import androidx.sqlite.db.SupportSQLiteDatabase // Import SupportSQLiteDatabase




/**
* The Room database for the application.
* Contains the usage_stats table.
*/
@Database(
   entities = [UsageStatEntity::class], // List all entities (tables)
   version = 2,                          // <<< INCREMENT VERSION to 2
   exportSchema = true                  // Set true to export schema for version control/migration testing
)
abstract class AppDatabase : RoomDatabase() {


   // Abstract function to get the DAO for the UsageStatEntity table
   abstract fun usageStatDao(): UsageStatDao


   // Companion object to provide a singleton instance of the database
   companion object {
       // Volatile ensures visibility of writes across threads
       @Volatile
       private var INSTANCE: AppDatabase? = null


       fun getDatabase(context: Context): AppDatabase {
           // Return existing instance if available
           // Otherwise, create a new database instance synchronized to avoid race conditions
           return INSTANCE ?: synchronized(this) {
               val instance = Room.databaseBuilder(
                   context.applicationContext, // Use application context
                   AppDatabase::class.java,
                   "zario_app_database" // Name of the database file
               )
                   // *** ADD MIGRATION from version 1 to 2 ***
                   .addMigrations(MIGRATION_1_2)
                   // to prevent data loss or app crashes.
                   .build()
               INSTANCE = instance
               // Return the newly created instance
               instance
           }
       }


       // --- Migration from version 1 to 2 (Table Recreation Strategy) ---
       val MIGRATION_1_2 = object : Migration(1, 2) {
           override fun migrate(db: SupportSQLiteDatabase) {
               Log.d("AppDatabaseMigration", "Running Migration 1 -> 2 (Recreate Table)")


               // 1. Create the new table with the target schema (V2)
               //    Ensure column names and types match UsageStatEntity exactly.
               //    Define constraints (PRIMARY KEY, NOT NULL) as expected by Room.
               db.execSQL("""
                   CREATE TABLE usage_stats_new (
                       id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                       userId TEXT NOT NULL,
                       packageName TEXT NOT NULL,
                       durationMs INTEGER NOT NULL,
                       intervalStartTimestamp INTEGER NOT NULL,
                       intervalEndTimestamp INTEGER NOT NULL,
                       dayTimestamp INTEGER NOT NULL,
                       isSynced INTEGER NOT NULL DEFAULT 0
                   )
               """.trimIndent())
               Log.d("AppDatabaseMigration", "Created usage_stats_new table")


               // 2. Copy data from the old table (usage_stats) to the new table (usage_stats_new)
               //    Provide a sensible default for the new 'userId' column for any existing V1 rows.
               //    Since data should be cleared, this might not copy anything, but it's robust.
               //    Use a placeholder like 'unknown_migrated' or an empty string.
               //    Set isSynced to 0 for all migrated rows.
               db.execSQL("""
                   INSERT INTO usage_stats_new (id, userId, packageName, durationMs, intervalStartTimestamp, intervalEndTimestamp, dayTimestamp, isSynced)
                   SELECT id, '', packageName, durationMs, intervalStartTimestamp, intervalEndTimestamp, dayTimestamp, 0
                   FROM usage_stats
               """.trimIndent())
               // Note: Using '' for userId default during copy. App logic should handle this.
               Log.d("AppDatabaseMigration", "Copied data from usage_stats to usage_stats_new")


               // 3. Drop the old table (V1)
               db.execSQL("DROP TABLE usage_stats")
               Log.d("AppDatabaseMigration", "Dropped old usage_stats table")


               // 4. Rename the new table to the original name
               db.execSQL("ALTER TABLE usage_stats_new RENAME TO usage_stats")
               Log.d("AppDatabaseMigration", "Renamed usage_stats_new to usage_stats")


               // 5. Re-create indices needed for V2 on the final table
               //    Index on userId is needed.
               db.execSQL("CREATE INDEX IF NOT EXISTS index_usage_stats_userId ON usage_stats(userId)")
               //    The old index on (dayTimestamp, packageName) is NOT recreated as it's not in the V2 entity definition.
               Log.d("AppDatabaseMigration", "Recreated indices on new usage_stats table")


               Log.d("AppDatabaseMigration", "Migration 1 -> 2 (Recreate Table) Finished")
           }
       }
       // --- End Migration 1-2 ---
   }
}


</AppDatabase>




<UsageStatDao>
package com.niyaz.zario.data.local


import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update // Import Update
import kotlinx.coroutines.flow.Flow // Use Flow for observable queries


/**
* Data Access Object (DAO) for the UsageStatEntity table.
*/
@Dao
interface UsageStatDao {


   // --- Existing methods (No change needed in signature, Room handles mapping) ---
   @Insert(onConflict = OnConflictStrategy.REPLACE)
   suspend fun insertUsageStat(usageStat: UsageStatEntity)


   @Insert(onConflict = OnConflictStrategy.REPLACE)
   suspend fun insertAllUsageStats(usageStats: List<UsageStatEntity>)


   // --- Queries might need userId filter if not implicitly handled by app logic elsewhere ---
   // Note: Added userId filter to most queries to ensure data isolation per user
   @Query("SELECT SUM(durationMs) FROM usage_stats WHERE userId = :userId AND packageName = :packageName AND dayTimestamp = :dayTimestamp")
   suspend fun getTotalDurationForAppOnDay(userId: String, packageName: String, dayTimestamp: Long): Long?


   // Assuming range queries are user-specific too
   @Query("SELECT SUM(durationMs) FROM usage_stats WHERE userId = :userId AND packageName = :packageName AND intervalStartTimestamp >= :startTime AND intervalEndTimestamp <= :endTime")
   suspend fun getTotalDurationForAppInRange(userId: String, packageName: String, startTime: Long, endTime: Long): Long?


   @Query("SELECT * FROM usage_stats WHERE userId = :userId AND dayTimestamp = :dayTimestamp ORDER BY intervalStartTimestamp ASC")
   fun getUsageStatsForDayFlow(userId: String, dayTimestamp: Long): Flow<List<UsageStatEntity>>


   // Aggregated flows often used for user's view, so add userId
   @Query("SELECT dayTimestamp, SUM(durationMs) as totalDuration FROM usage_stats WHERE userId = :userId AND packageName = :packageName GROUP BY dayTimestamp ORDER BY dayTimestamp DESC")
   fun getAggregatedDailyDurationForAppFlow(userId: String, packageName: String): Flow<List<DailyDuration>>


   // Today's usage flow needs userId
   @Query("SELECT SUM(durationMs) FROM usage_stats WHERE userId = :userId AND packageName = :packageName AND dayTimestamp = :todayDayTimestamp")
   fun getTodayUsageForAppFlow(userId: String, packageName: String, todayDayTimestamp: Long): Flow<Long?>


   // --- Baseline Queries likely need userId filter too ---
   @Query("""
       SELECT packageName, SUM(durationMs) as totalDurationMs
       FROM usage_stats
       WHERE userId = :userId AND intervalEndTimestamp > :startTime AND intervalStartTimestamp < :endTime
       GROUP BY packageName
       HAVING SUM(durationMs) >= :minTotalDurationMs
       ORDER BY totalDurationMs DESC
   """)
   suspend fun getAggregatedUsageForBaseline(userId: String, startTime: Long, endTime: Long, minTotalDurationMs: Long = 60000): List<AppUsageBaseline> // Default min 1 minute


   @Query("""
       SELECT packageName, durationMs, intervalStartTimestamp
       FROM usage_stats
       WHERE userId = :userId AND intervalEndTimestamp > :startTime AND intervalStartTimestamp < :endTime
   """)
   suspend fun getAllUsageRecordsForBaseline(userId: String, startTime: Long, endTime: Long): List<BaselineUsageRecord>




   // --- NEW QUERIES/UPDATES FOR SYNC WORKER ---


   /**
    * Gets all usage records for a specific user that have not yet been synced.
    * Optionally limit the number of records fetched per batch.
    * Assumes UsageStatEntity has an 'isSynced' field (e.g., Boolean or Int 0/1)
    * and a primary key 'id'.
    * @param userId The ID of the user whose records to fetch.
    * @param limit Max number of records to return.
    * @return List of unsynced UsageStatEntity objects.
    */
   @Query("SELECT * FROM usage_stats WHERE userId = :userId AND isSynced = 0 ORDER BY intervalStartTimestamp ASC LIMIT :limit")
   suspend fun getUnsyncedUsageStats(userId: String, limit: Int = 100): List<UsageStatEntity> // Default limit 100


   /**
    * Updates a list of UsageStatEntity records, typically to mark them as synced.
    * Room matches entities based on their primary key.
    * @param stats The list of entities to update (should have primary key set).
    * @return The number of rows affected.
    */
   @Update
   suspend fun updateUsageStats(stats: List<UsageStatEntity>): Int


   /**
    * Marks specific usage stats as synced based on their IDs.
    * Use this if updating the entire entity is not desired or efficient.
    * Assumes UsageStatEntity has a primary key 'id'.
    * @param ids List of primary keys (id) of the records to mark as synced.
    */
   @Query("UPDATE usage_stats SET isSynced = 1 WHERE id IN (:ids)")
   suspend fun markUsageStatsAsSynced(ids: List<Long>)


}


// --- Data Classes for Query Results (No changes needed) ---


/** Data class for aggregated baseline usage per app. */
data class AppUsageBaseline(
   val packageName: String,
   val totalDurationMs: Long
)


/** Data class for individual records needed for hourly aggregation. */
data class BaselineUsageRecord(
   val packageName: String,
   val durationMs: Long,
   val intervalStartTimestamp: Long
)




/** Existing Data class */
data class DailyDuration(
   val dayTimestamp: Long,
   val totalDuration: Long
)


// NOTE: The UsageStatEntity definition is assumed to exist elsewhere and contain
// at least the following fields used in the queries:
// - id: Long (Primary Key)
// - userId: String
// - packageName: String
// - durationMs: Long
// - dayTimestamp: Long
// - intervalStartTimestamp: Long
// - intervalEndTimestamp: Long
// - isSynced: Boolean or Int (e.g., 0 for false, 1 for true)


</UsageStatDao>


<UsageStatEntity>
package com.niyaz.zario.data.local


import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey


/**
* Represents a single record of app usage duration within a specific interval.
*/
@Entity(tableName = "usage_stats") // Use the actual table name
data class UsageStatEntity(
   @PrimaryKey(autoGenerate = true)
   val id: Long = 0, // Keep primary key


   // Add userId to associate record with the logged-in user
   @ColumnInfo(index = true) // Index userId for faster queries in the worker
   val userId: String,


   val packageName: String, // Package name of the app used


   // Store duration in milliseconds for precision
   val durationMs: Long,


   // Store the start and end timestamps of the interval during which this duration occurred
   val intervalStartTimestamp: Long,
   val intervalEndTimestamp: Long,


   // Add a timestamp representing the start of the day (00:00:00) for easy daily aggregation
   val dayTimestamp: Long, // Keep dayTimestamp for potential daily queries


   // Add flag to track if this record has been synced to Firestore
   @ColumnInfo(defaultValue = "0") // Default to not synced (0 for false)
   val isSynced: Boolean = false
   // We could add a userId later if needed for multi-user support, but for now assume single user -> This comment is now outdated by the addition of userId
)


</UsageStatEntity>


<AppBaselineInfo>
package com.niyaz.zario.data.model // New package for data models


import android.graphics.drawable.Drawable


/**
* Data class holding baseline information for an application, suitable for UI display.
*/
data class AppBaselineInfo(
   val packageName: String,
   val appName: String,
   val averageDailyUsageMs: Long,
   val icon: Drawable?
)


</AppBaselineInfo>





<StudyRepository>
package com.niyaz.zario.data.repository


import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppUsageBaseline
import com.niyaz.zario.data.local.BaselineUsageRecord
import com.niyaz.zario.data.local.UsageStatEntity
import com.niyaz.zario.data.model.AppBaselineInfo
import kotlinx.coroutines.flow.Flow




/**
* Interface for accessing and manipulating study-related data.
* This abstracts the data sources (SharedPreferences, Room, Firestore, AppInfoHelper)
* from the ViewModels.
*/
interface StudyRepository {


   // --- Study State (from StudyStateManager / Firestore) ---


   fun getUserId(): String?
   suspend fun saveUserId(userId: String) // Added suspend as Firestore might be involved indirectly


   fun getStudyPhase(): StudyPhase
   suspend fun saveStudyPhase(phase: StudyPhase) // Suspend for potential Firestore update


   fun getStudyStartTimestamp(): Long
   suspend fun saveStudyStartTimestamp(timestamp: Long) // Suspend for potential Firestore update


   fun getCondition(): StudyPhase?
   suspend fun saveCondition(condition: StudyPhase) // Suspend for potential Firestore update


   fun getTargetApp(): String?
   suspend fun saveTargetApp(packageName: String?) // Suspend for potential Firestore update


   fun getDailyGoalMs(): Long?
   suspend fun saveDailyGoalMs(goalMs: Long?) // Suspend for potential Firestore update


   fun getPointsBalance(): Int
   suspend fun savePointsBalance(points: Int) // Suspend for potential Firestore update


   fun getFlexStakes(): Pair<Int?, Int?>
   suspend fun saveFlexStakes(earn: Int, lose: Int) // Suspend for potential Firestore update


   fun getLastDailyOutcome(): Triple<Long?, Boolean?, Int?>
   suspend fun saveDailyOutcome(checkTimestamp: Long, goalReached: Boolean, pointsChange: Int) // Suspend for potential Firestore update


   suspend fun fetchAndSaveStateFromFirestore(userId: String): Boolean // Keep this high-level operation
   suspend fun clearStudyState() // Suspend for potential related async operations


   // --- User Profile Data (Firestore) ---
   suspend fun saveUserProfile(userId: String, userData: Map<String, Any?>): Result<Unit> // Result type for better error handling
   // Add methods to get specific profile fields if needed, e.g., getRegistrationTimestamp(userId: String)


   // --- Usage Stats (from Room DAO) ---
   // Signatures updated to include userId where DAO requires it


   suspend fun insertUsageStat(usageStat: UsageStatEntity) // No change needed here
   suspend fun insertAllUsageStats(usageStats: List<UsageStatEntity>) // No change needed here
   suspend fun getTotalDurationForAppOnDay(userId: String, packageName: String, dayTimestamp: Long): Long?
   suspend fun getTotalDurationForAppInRange(userId: String, packageName: String, startTime: Long, endTime: Long): Long?
   fun getUsageStatsForDayFlow(userId: String, dayTimestamp: Long): Flow<List<UsageStatEntity>>
   fun getAggregatedDailyDurationForAppFlow(userId: String, packageName: String): Flow<List<com.niyaz.zario.data.local.DailyDuration>> // Use qualified name
   fun getTodayUsageForAppFlow(userId: String, packageName: String, todayDayTimestamp: Long): Flow<Long?>
   suspend fun getAggregatedUsageForBaseline(userId: String, startTime: Long, endTime: Long, minTotalDurationMs: Long = 60000): List<AppUsageBaseline>
   suspend fun getAllUsageRecordsForBaseline(userId: String, startTime: Long, endTime: Long): List<BaselineUsageRecord>


   // Sync methods are internal to worker or could be exposed if needed, but DAO is sufficient for now
   // suspend fun getUnsyncedUsageStats(userId: String, limit: Int = 100): List<UsageStatEntity> // Example if exposing needed
   // suspend fun markUsageStatsAsSynced(ids: List<Long>) // Example if exposing needed


   // --- App Info (from AppInfoHelper) ---
   // Consider renaming AppBaselineInfo and moving it to a shared data/model package
   suspend fun getAppDetails(packageName: String): AppBaselineInfo


   // --- Combined Operations (Example) ---
   // This combines state saving across local and remote sources
   suspend fun confirmGoalSelection(userId: String, selectedAppPkg: String, calculatedGoalMs: Long): Result<Unit>


   /**
    * Initializes a new user's profile in Firestore and sets initial local state.
    * Handles both remote and local persistence for registration.
    * @param userId The new user's Firebase Auth UID.
    * @param userProfileData Map containing initial profile data for Firestore (YOB, Gender, Email, Timestamps, Phase, Condition, Points etc.).
    * @param initialPhase The starting study phase enum value for local state.
    * @param assignedCondition The randomly assigned intervention condition enum value for local state.
    * @param initialPoints The starting points balance for local state.
    * @param registrationTimestamp The timestamp of registration/study start for local state.
    * @return Result indicating success or failure of the entire initialization process.
    */
   suspend fun initializeNewUser(
       userId: String,
       userProfileData: Map<String, Any?>, // Data destined for Firestore set()
       initialPhase: StudyPhase,          // Enum for local state save
       assignedCondition: StudyPhase,     // Enum for local state save
       initialPoints: Int,                // Int for local state save
       registrationTimestamp: Long        // Long for local state save
   ): Result<Unit>
}
</StudyRepository>







<StudyRepositoryImpl>
package com.niyaz.zario.data.repository


import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppUsageBaseline
import com.niyaz.zario.data.local.BaselineUsageRecord
import com.niyaz.zario.data.local.DailyDuration // Keep original import if correct
import com.niyaz.zario.data.local.UsageStatDao
import com.niyaz.zario.data.local.UsageStatEntity
import com.niyaz.zario.data.model.AppBaselineInfo
import com.niyaz.zario.utils.AppInfoHelper
import com.niyaz.zario.utils.Constants // Import Constants
import com.niyaz.zario.utils.StudyStateManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext


/**
* Concrete implementation of the StudyRepository interface.
* Manages data access across local (SharedPreferences, Room) and remote (Firestore) sources.
*
* @param context Application context, needed for SharedPreferences and AppInfoHelper.
* @param usageStatDao DAO for accessing Room database (usage stats).
* @param firestore Instance of FirebaseFirestore.
*/
class StudyRepositoryImpl(
   private val context: Context,
   private val usageStatDao: UsageStatDao,
   private val firestore: FirebaseFirestore = Firebase.firestore
) : StudyRepository {


   private val TAG = "StudyRepositoryImpl"


   // Helper to get current user ID safely
   private fun getCurrentUserId(): String? = StudyStateManager.getUserId(context)


   // Helper to update Firestore field(s) safely
   private suspend fun updateFirestoreField(userId: String, field: String, value: Any?): Boolean {
       return try {
           // Use constant for collection name
           firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)
               .update(field, value)
               .await()
           Log.d(TAG, "Firestore update successful for user $userId: $field = $value")
           true
       } catch (e: Exception) {
           Log.e(TAG, "Firestore update failed for user $userId: $field = $value", e)
           false
       }
   }
   private suspend fun updateFirestoreFields(userId: String, data: Map<String, Any?>): Boolean {
       return try {
           // Use constant for collection name
           firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)
               .update(data)
               .await()
           Log.d(TAG, "Firestore update successful for user $userId: ${data.keys}")
           true
       } catch (e: Exception) {
           Log.e(TAG, "Firestore update failed for user $userId: ${data.keys}", e)
           false
       }
   }




   // --- Study State (from StudyStateManager / Firestore) ---


   override fun getUserId(): String? = StudyStateManager.getUserId(context)


   // Saving UserID primarily happens locally during login/register success callbacks
   override suspend fun saveUserId(userId: String) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveUserId(context, userId)
       }
   }


   override fun getStudyPhase(): StudyPhase = StudyStateManager.getStudyPhase(context)


   override suspend fun saveStudyPhase(phase: StudyPhase) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveStudyPhase(context, phase)
           // Also update Firestore (uses helper which now uses constant collection name)
           getCurrentUserId()?.let { userId ->
               // Field name remains string literal here as per <change> focus
               updateFirestoreField(userId, Constants.FIRESTORE_FIELD_STUDY_PHASE, phase.name)


           }
       }
   }


   override fun getStudyStartTimestamp(): Long = StudyStateManager.getStudyStartTimestamp(context)


   override suspend fun saveStudyStartTimestamp(timestamp: Long) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveStudyStartTimestamp(context, timestamp)
           getCurrentUserId()?.let { userId ->
               // Field name remains string literal here
               updateFirestoreField(userId, Constants.FIRESTORE_FIELD_STUDY_START_TIMESTAMP, timestamp)
           }
       }
   }


   override fun getCondition(): StudyPhase? = StudyStateManager.getCondition(context)


   override suspend fun saveCondition(condition: StudyPhase) {
       withContext(Dispatchers.IO) {
           if (condition.name.startsWith("INTERVENTION")) {
               StudyStateManager.saveCondition(context, condition)
               getCurrentUserId()?.let { userId ->
                   // Field name remains string literal here
                   updateFirestoreField(userId, Constants.FIRESTORE_FIELD_STUDY_CONDITION, condition.name)
               }
           } else {
               Log.w(TAG,"Attempted to save invalid condition via repository: $condition")
           }
       }
   }


   override fun getTargetApp(): String? = StudyStateManager.getTargetApp(context)


   override suspend fun saveTargetApp(packageName: String?) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveTargetApp(context, packageName)
           getCurrentUserId()?.let { userId ->
               // Field name remains string literal here
               updateFirestoreField(userId, Constants.FIRESTORE_FIELD_TARGET_APP, packageName)
           }
       }
   }


   override fun getDailyGoalMs(): Long? = StudyStateManager.getDailyGoalMs(context)


   override suspend fun saveDailyGoalMs(goalMs: Long?) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveDailyGoalMs(context, goalMs)
           getCurrentUserId()?.let { userId ->
               // Field name remains string literal here
               updateFirestoreField(userId, Constants.FIRESTORE_FIELD_DAILY_GOAL, goalMs)
           }
       }
   }


   override fun getPointsBalance(): Int = StudyStateManager.getPointsBalance(context)


   override suspend fun savePointsBalance(points: Int) {
       withContext(Dispatchers.IO) {
           // Points are coerced in DailyCheckWorker, assume valid here for saving
           StudyStateManager.savePointsBalance(context, points)
           getCurrentUserId()?.let { userId ->
               // Field name remains string literal here
               updateFirestoreField(userId, Constants.FIRESTORE_FIELD_POINTS_BALANCE, points.toLong())
           }
       }
   }


   override fun getFlexStakes(): Pair<Int?, Int?> = StudyStateManager.getFlexStakes(context)


   override suspend fun saveFlexStakes(earn: Int, lose: Int) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveFlexStakes(context, earn, lose)
           getCurrentUserId()?.let { userId ->
               // Field names remain string literals here
               updateFirestoreFields(userId, mapOf(
                   Constants.FIRESTORE_FIELD_FLEX_EARN to earn.toLong(),
                   Constants.FIRESTORE_FIELD_FLEX_LOSE to lose.toLong()
               ))
           }
       }
   }


   override fun getLastDailyOutcome(): Triple<Long?, Boolean?, Int?> = StudyStateManager.getLastDailyOutcome(context)


   // Saving outcome is purely local state for the next day's notification
   override suspend fun saveDailyOutcome(checkTimestamp: Long, goalReached: Boolean, pointsChange: Int) {
       withContext(Dispatchers.IO) {
           StudyStateManager.saveDailyOutcome(context, checkTimestamp, goalReached, pointsChange)
       }
   }


   // High-level operation remains, implementation details are in StudyStateManager
   override suspend fun fetchAndSaveStateFromFirestore(userId: String): Boolean {
       // This already uses await and handles Firestore access internally
       // It will now benefit from constant collection name if StudyStateManager uses these helpers
       // or if it implements its own Firestore access using constants.
       return StudyStateManager.fetchAndSaveStateFromFirestore(context, userId)
   }


   override suspend fun clearStudyState() {
       withContext(Dispatchers.IO) {
           StudyStateManager.clearStudyState(context)
           // No direct Firestore interaction needed here, as it clears local prefs
       }
   }


   // --- User Profile Data (Firestore) ---
   override suspend fun saveUserProfile(userId: String, userData: Map<String, Any?>): Result<Unit> {
       return withContext(Dispatchers.IO) {
           try {
               // Use constant for collection name
               firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)
                   .set(userData) // Use set for initial creation
                   .await()
               Log.d(TAG, "User profile saved successfully to Firestore for user $userId")
               Result.success(Unit)
           } catch (e: Exception) {
               Log.e(TAG, "Failed to save user profile to Firestore for user $userId", e)
               Result.failure(e)
           }
       }
   }


   // --- Usage Stats (Implementations updated to pass userId) ---


   override suspend fun insertUsageStat(usageStat: UsageStatEntity) = withContext(Dispatchers.IO) {
       // Assumes usageStat already contains the correct userId set by the caller (Service)
       usageStatDao.insertUsageStat(usageStat)
   }


   override suspend fun insertAllUsageStats(usageStats: List<UsageStatEntity>) = withContext(Dispatchers.IO) {
       // Assumes usageStats list contains entities with correct userId set by the caller (Service)
       usageStatDao.insertAllUsageStats(usageStats)
   }


   override suspend fun getTotalDurationForAppOnDay(userId: String, packageName: String, dayTimestamp: Long): Long? = withContext(Dispatchers.IO) {
       usageStatDao.getTotalDurationForAppOnDay(userId, packageName, dayTimestamp) // Pass userId
   }


   override suspend fun getTotalDurationForAppInRange(userId: String, packageName: String, startTime: Long, endTime: Long): Long? = withContext(Dispatchers.IO) {
       usageStatDao.getTotalDurationForAppInRange(userId, packageName, startTime, endTime) // Pass userId
   }


   // Flows typically collected where userId is known (ViewModel)
   override fun getUsageStatsForDayFlow(userId: String, dayTimestamp: Long): Flow<List<UsageStatEntity>> {
       return usageStatDao.getUsageStatsForDayFlow(userId, dayTimestamp) // Pass userId
   }


   override fun getAggregatedDailyDurationForAppFlow(userId: String, packageName: String): Flow<List<DailyDuration>> {
       return usageStatDao.getAggregatedDailyDurationForAppFlow(userId, packageName) // Pass userId
   }


   override fun getTodayUsageForAppFlow(userId: String, packageName: String, todayDayTimestamp: Long): Flow<Long?> {
       // Note: This is the crucial one for HomeViewModel's main display
       return usageStatDao.getTodayUsageForAppFlow(userId, packageName, todayDayTimestamp) // Pass userId
   }


   override suspend fun getAggregatedUsageForBaseline(userId: String, startTime: Long, endTime: Long, minTotalDurationMs: Long): List<AppUsageBaseline> = withContext(Dispatchers.IO) {
       usageStatDao.getAggregatedUsageForBaseline(userId, startTime, endTime, minTotalDurationMs) // Pass userId
   }


   override suspend fun getAllUsageRecordsForBaseline(userId: String, startTime: Long, endTime: Long): List<BaselineUsageRecord> = withContext(Dispatchers.IO) {
       usageStatDao.getAllUsageRecordsForBaseline(userId, startTime, endTime) // Pass userId
   }




   // --- App Info (from AppInfoHelper) ---
   override suspend fun getAppDetails(packageName: String): AppBaselineInfo { // Update return type location
       return withContext(Dispatchers.IO) {
           val details = AppInfoHelper.getAppDetails(context, packageName)
           // Now uses the imported AppBaselineInfo
           AppBaselineInfo(
               packageName = packageName,
               appName = details.appName,
               icon = details.icon,
               averageDailyUsageMs = 0L // Still a placeholder here, calculated elsewhere
           )
       }
   }




   // --- Combined Operations ---
   override suspend fun confirmGoalSelection(userId: String, selectedAppPkg: String, calculatedGoalMs: Long): Result<Unit> {
       return withContext(Dispatchers.IO) {
           val condition = StudyStateManager.getCondition(context)
           if (condition == null) {
               return@withContext Result.failure(IllegalStateException("Cannot confirm goal: Condition not set."))
           }


           // 1. Persist locally
           StudyStateManager.saveTargetApp(context, selectedAppPkg)
           StudyStateManager.saveDailyGoalMs(context, calculatedGoalMs)
           StudyStateManager.saveStudyPhase(context, condition) // Transition to the specific intervention phase


           // 2. Update Firestore
           // Use constants for Firestore fields
           val updateData = mapOf(
               Constants.FIRESTORE_FIELD_TARGET_APP to selectedAppPkg,
               Constants.FIRESTORE_FIELD_DAILY_GOAL to calculatedGoalMs,
               Constants.FIRESTORE_FIELD_STUDY_PHASE to condition.name
           )
           // Update Firestore - updateFirestoreFields already logs internally and now uses constant collection name
           val success = updateFirestoreFields(userId, updateData)


           if (success) {
               Result.success(Unit)
           } else {
               // Optional: Consider rolling back local changes if Firestore fails critically?
               // For now, log the inconsistency.
               Log.e(TAG,"Goal selection saved locally but failed to update Firestore!")
               Result.failure(Exception("Failed to update Firestore during goal confirmation."))
           }
       }
   }


   override suspend fun initializeNewUser(
       userId: String,
       userProfileData: Map<String, Any?>,
       initialPhase: StudyPhase,
       assignedCondition: StudyPhase,
       initialPoints: Int,
       registrationTimestamp: Long
   ): Result<Unit> = withContext(Dispatchers.IO) { // Perform on IO thread
       try {
           // Step 1: Save profile data to Firestore
           // Uses constant collection name via Constants.kt
           firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)
               .set(userProfileData) // Use set for initial creation
               .await() // Wait for Firestore operation completion
           Log.d(TAG, "Firestore document successfully written for new user: $userId")


           // Step 2: Save initial state locally using StudyStateManager
           // Uses constant keys via Constants.kt implicitly within StateManager
           StudyStateManager.saveUserId(context, userId)
           StudyStateManager.saveStudyPhase(context, initialPhase) // Saves the Enum name
           StudyStateManager.saveCondition(context, assignedCondition) // Saves the Enum name
           StudyStateManager.savePointsBalance(context, initialPoints) // Saves the Int
           StudyStateManager.saveStudyStartTimestamp(context, registrationTimestamp) // Saves the Long
           // Ensure other potentially relevant states are cleared/defaulted locally
           StudyStateManager.saveTargetApp(context, null)
           StudyStateManager.saveDailyGoalMs(context, null)
           // Save default flex stakes locally even if not in flex condition initially
           StudyStateManager.saveFlexStakes(context, Constants.FLEX_STAKES_MIN_EARN, Constants.FLEX_STAKES_MIN_LOSE)
           StudyStateManager.saveDailyOutcome(context, 0L, false, 0) // Clear previous day outcome




           Log.d(TAG, "Local state initialized via StudyStateManager for new user: $userId")
           Result.success(Unit)


       } catch (e: Exception) {
           Log.e(TAG, "Failed to initialize new user $userId (Firestore set or Local save)", e)
           // The calling code (AuthScreen) should handle cleanup like deleting the Auth user if needed.
           Result.failure(e)
       }
   }
   // ... rest of StudyRepositoryImpl ... // This comment is illustrative, no actual code is omitted.
}
</StudyRepositoryImpl>





<Screen>
package com.niyaz.zario.navigation


// Defines the unique route strings for each screen in the navigation graph.
sealed class Screen(val route: String) {
   // Represents the initial screen users see, potentially deciding where to go next (Login/Main)
   // For now, let's assume it goes directly to a temporary "Home" or "Auth" choice screen.
   // Later this could be a Splash screen or logic to check login status.
   object AuthDecision : Screen("auth_decision_screen")


   object Login : Screen("login_screen")
   object Register : Screen("register_screen")


   // Placeholder for the main screen after login/registration
   // This will eventually host the dashboard, goal tracking, etc.
   object Home : Screen("home_screen")


   // We can add more routes here later (e.g., GoalSetting, History)
}


</Screen>




<UsageTrackingService>
package com.niyaz.zario.services // Ensure correct package


// --- Android & Core Imports ---
import android.Manifest
import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.app.usage.UsageEvents
import android.app.usage.UsageStatsManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat


// --- App Specific Imports ---
import com.niyaz.zario.MainActivity
import com.niyaz.zario.R
import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppDatabase
import com.niyaz.zario.data.local.UsageStatDao
import com.niyaz.zario.data.local.UsageStatEntity
import com.niyaz.zario.utils.AppInfoHelper
import com.niyaz.zario.utils.Constants // Import Constants
import com.niyaz.zario.utils.StudyStateManager


// --- Coroutine Imports ---
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Calendar
import java.util.concurrent.TimeUnit


class UsageTrackingService : Service() {


   // --- Coroutine Scope & Dependencies ---
   private val serviceJob = Job()
   private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob) // IO for DB/State access
   private lateinit var usageStatsManager: UsageStatsManager
   private lateinit var usageStatDao: UsageStatDao
   private lateinit var notificationManager: NotificationManagerCompat


   // --- Tracking State ---
   private var lastQueryEndTime: Long = 0L
   private var appInForegroundAtLastCheck: String? = null
   private var timestampOfLastForegroundEvent: Long = 0L


   // --- State for Intervention Notifications & Daily Tracking ---
   private var targetAppPackage: String? = null
   private var dailyGoalMs: Long? = null
   private var currentDayStartMs: Long = 0L // Start of the current tracking day (midnight)
   private var accumulatedUsageTodayMs: Long = 0L // Accumulated usage for target app today
   private var warnedAt90Percent = false // Flag: Already shown 90% warning today?
   private var warnedAt100Percent = false // Flag: Already shown 100% warning today?
   private var shownDailyFeedback = false // Flag: Shown the initial daily feedback today?


   companion object {
       private const val TAG = "UsageTrackingService"
       // Use constants for channel ID and notification IDs
       private const val NOTIFICATION_CHANNEL_ID = Constants.USAGE_TRACKING_CHANNEL_ID
       private const val FOREGROUND_NOTIFICATION_ID = Constants.USAGE_TRACKING_FOREGROUND_NOTIF_ID
       private const val DAILY_FEEDBACK_NOTIFICATION_ID = Constants.USAGE_TRACKING_DAILY_FEEDBACK_NOTIF_ID
       private const val USAGE_WARNING_90_NOTIFICATION_ID = Constants.USAGE_TRACKING_WARN_90_NOTIF_ID
       private const val USAGE_LIMIT_100_NOTIFICATION_ID = Constants.USAGE_TRACKING_LIMIT_100_NOTIF_ID
       // Use constants for interval and min duration
       private val TRACKING_INTERVAL_MS = Constants.USAGE_TRACKING_INTERVAL_MS
       private const val MIN_DB_SAVE_DURATION_MS = Constants.USAGE_TRACKING_MIN_SAVE_DURATION_MS
   }


   // --- Service Lifecycle ---
   override fun onCreate() {
       super.onCreate()
       Log.d(TAG, "Service onCreate")
       try {
           usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
           val database = AppDatabase.getDatabase(applicationContext)
           usageStatDao = database.usageStatDao()
           notificationManager = NotificationManagerCompat.from(this)


           val initTime = System.currentTimeMillis()
           lastQueryEndTime = initTime
           timestampOfLastForegroundEvent = initTime
           appInForegroundAtLastCheck = null // Will determine on first proper query


           // Load initial intervention state and reset daily counters if needed
           loadInterventionState(true) // Pass true to potentially load today's usage from DB


           createNotificationChannel() // Ensure channel exists
           // Use constant for notification ID
           startForeground(FOREGROUND_NOTIFICATION_ID, createForegroundNotification())
           Log.d(TAG, "Dependencies initialized and service started in foreground.")
       } catch (e: Exception) {
           Log.e(TAG, "Error during onCreate initialization: ${e.message}", e)
           stopSelf() // Stop if critical initialization fails
       }
   }


   override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
       Log.d(TAG, "Service onStartCommand received.")
       // Reload intervention state in case goal was just set or changed
       loadInterventionState(false) // Don't reload from DB here, just refresh state vars


       if (serviceScope.isActive && serviceJob.children.count() > 0) {
           Log.w(TAG, "Tracking loop already running. Ignoring redundant start command.")
           return START_STICKY
       }
       serviceScope.launch { trackUsage() }
       return START_STICKY
   }


   override fun onDestroy() {
       super.onDestroy()
       Log.d(TAG, "Service onDestroy")
       serviceJob.cancel() // Cancel all coroutines
       Log.d(TAG, "Service scope cancelled.")
       // Consider stopping foreground explicitly: stopForeground(STOP_FOREGROUND_REMOVE)
   }


   override fun onBind(intent: Intent?): IBinder? = null // Not binding


   // --- State Loading ---
   /**
    * Loads target app, goal, and current day start time from SharedPreferences.
    * Resets daily accumulated usage and notification flags if the day has changed.
    * Optionally attempts to load today's accumulated usage from the DB on initial load.
    */
   private fun loadInterventionState(loadFromDbOnNewDay: Boolean) {
       Log.d(TAG, "Loading/Refreshing Intervention State. Load from DB on new day: $loadFromDbOnNewDay") // Add logging clarity


       // --- 1. Store Previous State for Comparison ---
       val previousTarget = targetAppPackage
       val previousGoal = dailyGoalMs


       // --- 2. Load Current Persisted State ---
       // Retrieves target app and goal from StudyStateManager (SharedPreferences)
       targetAppPackage = StudyStateManager.getTargetApp(applicationContext)
       dailyGoalMs = StudyStateManager.getDailyGoalMs(applicationContext)


       // --- 3. Check if Target App or Goal Changed Mid-Day ---
       if (targetAppPackage != previousTarget || dailyGoalMs != previousGoal) {
           Log.i(TAG, "Intervention state (target/goal) changed: Target=$targetAppPackage, Goal=$dailyGoalMs ms")
           // Reset daily accumulator if target/goal changes mid-day to avoid mixing data
           accumulatedUsageTodayMs = 0L
           warnedAt90Percent = false
           warnedAt100Percent = false
           // Note: shownDailyFeedback flag is based on the *previous* day's outcome,
           // so it is NOT reset here, only on actual day change.
       }


       // --- 4. Check for Day Rollover ---
       val todayStart = getStartOfDayTimestamp(System.currentTimeMillis())
       if (todayStart != currentDayStartMs) {
           Log.i(TAG,"New day detected. Previous day start: $currentDayStartMs, New day start: $todayStart")


           // --- 4a. Reset Daily Counters and Notification Flags ---
           currentDayStartMs = todayStart
           accumulatedUsageTodayMs = 0L // Reset accumulated usage for the new day
           warnedAt90Percent = false    // Reset 90% warning flag
           warnedAt100Percent = false   // Reset 100% limit flag
           shownDailyFeedback = false   // Reset daily feedback flag (new day, needs new trigger)


           // --- 4b. Optional: Load Initial Usage from DB ---
           // If the service restarted or this is the first check of a new day,
           // try to load any usage that might have been recorded for today
           // before this state load occurred (e.g., between midnight and service start).
           if (loadFromDbOnNewDay && targetAppPackage != null) {
               // Launch background coroutine for DB read
               CoroutineScope(Dispatchers.IO).launch {
                   try {
                       // --- Get current userId for the DAO call ---
                       val currentUserId = StudyStateManager.getUserId(applicationContext)
                       if (currentUserId == null) {
                           Log.e(TAG, "Cannot load initial usage from DB: User ID is null.")
                           return@launch // Exit coroutine if no user ID
                       }
                       // --- End Get userId ---


                       Log.d(TAG, "Attempting to load initial usage for today ($currentDayStartMs) from DB for $targetAppPackage")
                       // --- Corrected DAO Call: Pass userId, packageName, dayTimestamp ---
                       val usageTodaySoFar = usageStatDao.getTotalDurationForAppOnDay(
                           userId = currentUserId,
                           packageName = targetAppPackage!!, // Now correct position
                           dayTimestamp = currentDayStartMs  // Now correct position
                       ) ?: 0L
                       // --- End Corrected DAO Call ---


                       if (usageTodaySoFar > 0) {
                           Log.d(TAG, "Loaded ${usageTodaySoFar / 1000.0}s of initial usage for today from DB.")
                           // Update the main accumulator on the service's scope
                           withContext(serviceScope.coroutineContext) {
                               accumulatedUsageTodayMs = usageTodaySoFar
                               // Immediately re-check notifications based on potentially loaded value
                               dailyGoalMs?.let { checkUsageLimitNotifications(accumulatedUsageTodayMs, it) }
                           }
                       } else {
                           Log.d(TAG, "No initial usage found in DB for today.")
                       }
                   } catch (e: Exception) {
                       Log.e(TAG, "Error loading today's initial usage from DB", e)
                   }
               } // End CoroutineScope launch
           } // End Optional DB Load


       } // End Day Change Check


       // --- 5. Log Final State After Load/Refresh ---
       Log.d(TAG, "State Loaded/Refreshed: Target=$targetAppPackage, Goal=$dailyGoalMs ms, DayStart=$currentDayStartMs, AccumUsage=${accumulatedUsageTodayMs}ms, Warn90=$warnedAt90Percent, Warn100=$warnedAt100Percent, FeedbackShown=$shownDailyFeedback")
   }


   // --- Notification Setup ---
   private fun createNotificationChannel() {
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
           val importance = NotificationManager.IMPORTANCE_DEFAULT
           // Use stringResource for channel name and description
           val channelName = getString(R.string.notification_channel_name)
           val channelDescription = getString(R.string.notification_channel_description)
           // Use constant for channel ID
           val channel = NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName, importance).apply {
               description = channelDescription
           }
           getSystemService(NotificationManager::class.java)?.createNotificationChannel(channel)
           Log.d(TAG,"Notification channel created or verified: $NOTIFICATION_CHANNEL_ID")
       }
   }


   /** Creates the persistent notification for the foreground service itself. */
   private fun createForegroundNotification(): Notification {
       val notificationIcon = R.drawable.ic_tracking_notification // Use your drawable icon
       // Use stringResource for title and text
       val title = getString(R.string.notification_foreground_title)
       val text = getString(R.string.notification_foreground_text)


       // Use constant for channel ID
       return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
           .setContentTitle(title) // Use localized title
           .setContentText(text)   // Use localized text
           .setSmallIcon(notificationIcon)
           .setPriority(NotificationCompat.PRIORITY_LOW) // Keep low priority for foreground service itself
           .setOngoing(true) // Makes it non-dismissible
           .build()
   }


   /** Shows the specific intervention-related notifications (Daily Feedback, Warnings). */
   private fun showInterventionNotification(id: Int, title: String, message: String) {
       // Intent to open MainActivity when notification is clicked
       val intent = Intent(this, MainActivity::class.java).apply {
           // Flags bring the existing task to front or start new if needed
           flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK // Or FLAG_ACTIVITY_SINGLE_TOP? Test needed.
           // TODO: Add extras if needed to navigate to specific Composable in MainActivity
           // putExtra("destination_route", Screen.History.route) // Example
       }
       // Unique request code per notification ID is important for PendingIntent uniqueness
       val pendingIntent: PendingIntent = PendingIntent.getActivity(
           this,
           id, // Use notification ID as request code
           intent,
           PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT // Update current if intent changes
       )


       // Use constant for channel ID
       val notification = NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
           .setSmallIcon(R.drawable.ic_tracking_notification) // Use your drawable icon
           .setContentTitle(title) // Title is passed in, often constructed with stringResource
           .setContentText(message) // Message is passed in, often constructed with stringResource
           .setStyle(NotificationCompat.BigTextStyle().bigText(message)) // Show full message text
           .setPriority(NotificationCompat.PRIORITY_DEFAULT) // Default priority for user updates
           .setContentIntent(pendingIntent) // Intent to launch on tap
           .setAutoCancel(true) // Dismiss notification when tapped
           .build()


       // Check for notification permission before posting (Android 13+)
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU &&
           ActivityCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED)
       {
           Log.w(TAG, "Cannot show notification ID $id: POST_NOTIFICATIONS permission not granted.")
           // We cannot request permission from a service. The Activity should handle it.
           return
       }


       try {
           notificationManager.notify(id, notification) // Use unique ID
           Log.d(TAG, "Showing notification ID $id: '$title'")
       } catch (e: SecurityException) {
           // This might happen on some devices even if permission seems granted initially
           Log.e(TAG, "SecurityException showing notification ID $id: ${e.message}", e)
       } catch (e: Exception) {
           Log.e(TAG, "Error showing notification ID $id: ${e.message}", e)
       }
   }




   // --- Tracking & Notification Logic ---
   private suspend fun trackUsage() {
       // Use constant for interval logging
       Log.i(TAG, "Starting usage tracking loop. Interval: ${TRACKING_INTERVAL_MS / 1000} seconds.")
       try {
           while (currentCoroutineContext().isActive) {
               val currentTime = System.currentTimeMillis()
               val intervalStartTime = lastQueryEndTime
               val intervalEndTime = currentTime


               // --- Check for Day Change & Reload State ---
               // Handle potential day rollover before processing the interval
               if (getStartOfDayTimestamp(currentTime) != currentDayStartMs) {
                   Log.d(TAG,"Day change detected during loop.")
                   loadInterventionState(true) // Reload state and reset daily counters
               }


               // Proceed only if interval is valid
               if (intervalEndTime > intervalStartTime) {
                   // Process events and get usage data for the interval
                   val intervalUsageData = processUsageEventsForInterval(intervalStartTime, intervalEndTime)


                   // --- Save Interval Data to DB ---
                   if (intervalUsageData.entities.isNotEmpty()) {
                       insertUsageData(intervalUsageData.entities)
                   }


                   // --- Update Daily Accumulator & Check Notifications ---
                   val phase = StudyStateManager.getStudyPhase(applicationContext)
                   val isInterventionPhase = phase.name.startsWith("INTERVENTION")
                   val targetAppSet = targetAppPackage != null // Renamed for clarity from currentTargetAppPackage check below
                   val goalSet = dailyGoalMs != null


                   if (isInterventionPhase && targetAppSet && goalSet) {
                       // Update today's total usage from the interval data map
                       val usageInInterval = intervalUsageData.usageMap[targetAppPackage!!] ?: 0L // Use non-null asserted target
                       if (usageInInterval > 0) {
                           // Add usage from this interval to today's running total
                           accumulatedUsageTodayMs += usageInInterval
                           Log.d(TAG, "Target app usage in interval: ${usageInInterval / 1000.0}s. Today's total: ${accumulatedUsageTodayMs / 1000.0}s")
                       }


                       // --- Check for Daily Feedback Notification (FR-050) ---
                       // Condition: Target app was foreground AND feedback not shown today
                       if (!shownDailyFeedback && intervalUsageData.foregroundApp == targetAppPackage) {
                           handleDailyFeedbackNotification()
                           shownDailyFeedback = true // Mark as shown for today
                       }


                       // --- Check for Usage Limit Notifications (FR-051, FR-052) ---
                       checkUsageLimitNotifications(accumulatedUsageTodayMs, dailyGoalMs!!) // Use non-null asserted goal


                   } else {
                       // Log only if intervention phase active but target/goal missing (shouldn't normally happen)
                       // Keep original logic here: Log if in intervention phase but target OR goal is missing.
                       if (isInterventionPhase) {
                           Log.w(TAG, "In intervention phase but missing target/goal (TargetSet: $targetAppSet, GoalSet: $goalSet). Skipping notification checks.")
                       }
                   }


                   // Update the end time marker for the next query
                   lastQueryEndTime = intervalEndTime
               } else {
                   Log.w(TAG, "Current time ($intervalEndTime) <= last query end time ($intervalStartTime). Skipping query to avoid issues.")
                   // Advance timestamp to prevent potential infinite loops if clock goes backward slightly
                   lastQueryEndTime = intervalEndTime
               }
               // Wait for the defined interval before the next check
               // Use constant for delay
               delay(TRACKING_INTERVAL_MS)
           }
       } catch (e: CancellationException) {
           Log.i(TAG, "Usage tracking loop cancelled.")
       } catch (e: Exception) {
           Log.e(TAG, "Error within tracking loop: ${e.message}", e)
           // Consider more robust error handling, e.g., stopping service if UsageStatsManager fails repeatedly
       } finally {
           Log.i(TAG, "Usage tracking loop finishing.")
       }
   }


   /** Helper data class to return multiple pieces of info from event processing */
   private data class IntervalProcessingResult(
       val entities: List<UsageStatEntity> = emptyList(),
       val usageMap: Map<String, Long> = emptyMap(), // Map of Pkg -> DurationMs for *this interval*
       val foregroundApp: String? = null // Which app was foreground at the end of processing this interval
   )


   /** Processes events for an interval, returning entities, usage map, and last foreground app. */
   private fun processUsageEventsForInterval(intervalStartTime: Long, intervalEndTime: Long): IntervalProcessingResult {
       // --- Query Events ---
       val usageEvents: UsageEvents? = try { usageStatsManager.queryEvents(intervalStartTime, intervalEndTime) }
       catch (e: SecurityException) { Log.e(TAG, "QueryEvents SecurityException: ${e.message}"); return IntervalProcessingResult() }
       catch (e: Exception) { Log.e(TAG, "QueryEvents Exception: ${e.message}"); return IntervalProcessingResult() }
       if (usageEvents == null) { Log.w(TAG, "queryEvents returned null."); return IntervalProcessingResult() }


       // --- Process Events ---
       val intervalUsageMap = mutableMapOf<String, Long>() // Usage durations calculated *within this interval*
       var currentForegroundApp = appInForegroundAtLastCheck // Start with state from previous interval end
       var lastEventTimestamp = timestampOfLastForegroundEvent // Use marker from previous relevant event


       // Carry over duration for app foreground at start of interval
       if (currentForegroundApp != null && lastEventTimestamp < intervalStartTime) {
           val initialDuration = intervalStartTime - lastEventTimestamp
           if (initialDuration > 0) intervalUsageMap[currentForegroundApp] = intervalUsageMap.getOrDefault(currentForegroundApp, 0L) + initialDuration
           lastEventTimestamp = intervalStartTime // Align marker to interval start
       } else if (lastEventTimestamp < intervalStartTime) {
           lastEventTimestamp = intervalStartTime // Align marker if no app was foreground
       }


       val event = UsageEvents.Event()
       var lastProcessedEventTimestamp = lastEventTimestamp // Track latest event time processed *within this loop*


       while (usageEvents.hasNextEvent()) {
           usageEvents.getNextEvent(event)
           val eventTimestamp = event.timeStamp.coerceAtLeast(intervalStartTime) // Clamp event time to interval start


           // Calculate duration for the *previous* state before processing the current event
           if (currentForegroundApp != null) {
               val segmentStartTime = maxOf(lastEventTimestamp, intervalStartTime) // Start from interval boundary or last event
               if (eventTimestamp > segmentStartTime) {
                   val duration = eventTimestamp - segmentStartTime
                   intervalUsageMap[currentForegroundApp] = intervalUsageMap.getOrDefault(currentForegroundApp, 0L) + duration
               }
           }


           // Update state based on the current event
           when (event.eventType) {
               UsageEvents.Event.MOVE_TO_FOREGROUND -> {
                   currentForegroundApp = event.packageName
                   lastEventTimestamp = eventTimestamp // Mark the start time
               }
               UsageEvents.Event.MOVE_TO_BACKGROUND -> {
                   if (event.packageName == currentForegroundApp) {
                       currentForegroundApp = null // App went to background
                   }
                   // Always update lastEventTimestamp even if a different app went BG
                   lastEventTimestamp = maxOf(lastEventTimestamp, eventTimestamp)
               }
               // Other events just update the timestamp marker to keep duration calculation accurate
               else -> {
                   lastEventTimestamp = maxOf(lastEventTimestamp, eventTimestamp)
               }
           }
           lastProcessedEventTimestamp = maxOf(lastProcessedEventTimestamp, eventTimestamp) // Track latest event processed
       }


       // --- Handle App Still in Foreground at End of Interval ---
       val finalSegmentStartTime = maxOf(lastEventTimestamp, intervalStartTime)
       if (currentForegroundApp != null && intervalEndTime > finalSegmentStartTime) {
           val finalDuration = intervalEndTime - finalSegmentStartTime
           if (finalDuration > 0) intervalUsageMap[currentForegroundApp] = intervalUsageMap.getOrDefault(currentForegroundApp, 0L) + finalDuration
           timestampOfLastForegroundEvent = intervalEndTime // Update service state marker
       } else {
           // If no app FG or last event was at/after end time, update marker
           timestampOfLastForegroundEvent = maxOf(lastProcessedEventTimestamp, intervalEndTime)
       }
       // Update service state for next interval
       appInForegroundAtLastCheck = currentForegroundApp


       // --- Convert to Entities (Filter by MIN_DB_SAVE_DURATION_MS) ---
       val entities = mutableListOf<UsageStatEntity>()
       val dayTimestamp = getStartOfDayTimestamp(intervalStartTime)
       // Get current user ID (might need to read from StudyStateManager if not readily available)
       // IMPORTANT: Service runs independently, need reliable way to get current userId.
       // Reading from StudyStateManager (Prefs) is feasible but ensure it's up-to-date.
       val currentUserId = StudyStateManager.getUserId(applicationContext) // Get userId here


       // Check if userId is available before creating entities
       if (currentUserId == null) {
           Log.e(TAG, "Cannot create UsageStatEntity: User ID is null in service.")
           // Return empty result or handle error appropriately
           return IntervalProcessingResult(usageMap = intervalUsageMap, foregroundApp = currentForegroundApp) // Return partial result
       }


       intervalUsageMap.forEach { (pkg, duration) ->
           // Use constant for minimum save duration
           if (duration >= MIN_DB_SAVE_DURATION_MS) { // Only save significant chunks to DB
               // Add userId and set isSynced to false
               entities.add(
                   UsageStatEntity(
                       // id = 0 (auto-generated) // Keep default
                       userId = currentUserId,         // Add the userId
                       packageName = pkg,
                       durationMs = duration,
                       intervalStartTimestamp = intervalStartTime,
                       intervalEndTimestamp = intervalEndTime,
                       dayTimestamp = dayTimestamp,
                       isSynced = false                // Explicitly set to false
                   )
               )
           }
       }
       if (entities.isNotEmpty()) Log.d(TAG,"Prepared ${entities.size} entities for DB insertion from interval.")


       return IntervalProcessingResult(entities, intervalUsageMap, currentForegroundApp)
   }


   /** Inserts usage data into Room DB. */
   private suspend fun insertUsageData(entities: List<UsageStatEntity>) {
       if (entities.isEmpty()) return // Skip if nothing to insert
       try {
           usageStatDao.insertAllUsageStats(entities)
           Log.i(TAG, "Successfully inserted ${entities.size} usage stat records.")
       } catch (e: Exception) {
           Log.e(TAG, "Error inserting usage data into database: ${e.message}", e)
       }
   }


   /** Gets start of day timestamp. */
   private fun getStartOfDayTimestamp(timestamp: Long): Long {
       val calendar = Calendar.getInstance().apply {
           timeInMillis = timestamp
           set(Calendar.HOUR_OF_DAY, 0)
           set(Calendar.MINUTE, 0)
           set(Calendar.SECOND, 0)
           set(Calendar.MILLISECOND, 0)
       }
       return calendar.timeInMillis
   }


   // --- Notification Helper Functions ---


   /** Checks if daily feedback notification needs to be shown. */
   private fun handleDailyFeedbackNotification() {
       // Ensure we have the outcome from the previous day's check
       val (lastCheckTime, lastGoalReached, lastPointsChange) = StudyStateManager.getLastDailyOutcome(applicationContext)
       val todayStart = getStartOfDayTimestamp(System.currentTimeMillis())
       // Check timestamp corresponds to roughly the last 24 hours (covers worker running slightly late/early)
       val validOutcomeTime = lastCheckTime != null && lastCheckTime >= todayStart - TimeUnit.DAYS.toMillis(1) - TimeUnit.HOURS.toMillis(6) // Allow some buffer


       if (validOutcomeTime && lastGoalReached != null && lastPointsChange != null) {
           Log.d(TAG, "Attempting to show daily feedback notification.")
           val title = getString(R.string.notification_daily_feedback_title) // Use stringResource
           val points = lastPointsChange // Use the actual change value
           val pointsUnit = getString(R.string.points_unit) // Get points unit
           val message = if (lastGoalReached) {
               // Use stringResource for success message
               getString(R.string.notification_daily_feedback_success, points, pointsUnit)
           } else {
               // Use stringResource for fail message, display points loss as positive
               getString(R.string.notification_daily_feedback_fail, -points, pointsUnit)
           }
           val currentPoints = StudyStateManager.getPointsBalance(applicationContext)
           // Use stringResource for balance suffix
           val fullMessage = message + " " + getString(R.string.notification_daily_feedback_balance_suffix, currentPoints, pointsUnit)


           // Use constant for notification ID
           showInterventionNotification(DAILY_FEEDBACK_NOTIFICATION_ID, title, fullMessage)
       } else {
           Log.w(TAG,"Skipping daily feedback: No valid outcome data found for previous day (LastCheck: $lastCheckTime, TodayStart: $todayStart).")
       }
   }


   /** Checks accumulated usage against goal and triggers 90%/100% notifications. */
   @SuppressLint("StringFormatMatches")
   private fun checkUsageLimitNotifications(accumulatedMs: Long, goalMs: Long) {
       // Avoid division by zero or issues if goal is invalid
       if (goalMs <= 0) {
           Log.w(TAG, "checkUsageLimitNotifications skipped: Invalid goalMs ($goalMs)")
           return
       }


       // Capture current value and check for null
       val currentTargetAppPackage = targetAppPackage
       if (currentTargetAppPackage == null) {
           Log.e(TAG, "checkUsageLimitNotifications skipped: targetAppPackage is null unexpectedly.")
           return // Use return instead of elvis operator from <change> for clarity
       }


       val usagePercent = (accumulatedMs.toDouble() / goalMs.toDouble()) * 100.0
       // Use AppInfoHelper for consistent app name fetching
       val targetAppName = AppInfoHelper.getAppName(applicationContext, currentTargetAppPackage)
       val pointsUnit = getString(R.string.points_unit) // Get points unit


       // 90% Warning (FR028)
       if (usagePercent >= 90 && !warnedAt90Percent) {
           val title = getString(R.string.notification_warning_90_title) // Use stringResource
           val remainingMs = (goalMs - accumulatedMs).coerceAtLeast(0)
           val remainingMinutes = TimeUnit.MILLISECONDS.toMinutes(remainingMs)
           val goalMinutesTotal = TimeUnit.MILLISECONDS.toMinutes(goalMs)
           val usedMinutes = TimeUnit.MILLISECONDS.toMinutes(accumulatedMs)
           // Use stringResource for the message
           val message = getString(R.string.notification_warning_90_message, usedMinutes, goalMinutesTotal, targetAppName, remainingMinutes)


           // Use constant for notification ID
           showInterventionNotification(USAGE_WARNING_90_NOTIFICATION_ID, title, message)
           warnedAt90Percent = true // Set flag so it only shows once per day
           Log.i(TAG,"Showing 90% usage warning notification.")
       }


       // 100% Limit Reached (FR029)
       if (usagePercent >= 100 && !warnedAt100Percent) {
           val title = getString(R.string.notification_limit_100_title) // Use stringResource
           val goalMinutes = TimeUnit.MILLISECONDS.toMinutes(goalMs)


           val condition = StudyStateManager.getCondition(applicationContext)
           // Use stringResource for consequence messages
           // Use constant for points value comparison
           val pointConsequence = when(condition) {
               StudyPhase.INTERVENTION_CONTROL -> getString(R.string.notification_limit_100_consequence_control)
               StudyPhase.INTERVENTION_DEPOSIT -> getString(R.string.notification_limit_100_consequence_deposit, Constants.DEFAULT_DEPOSIT_LOSE_POINTS, pointsUnit) // Use Constant
               StudyPhase.INTERVENTION_FLEXIBLE -> {
                   val (_, lose) = StudyStateManager.getFlexStakes(applicationContext)
                   // Use constants for range check
                   if (lose != null && lose > Constants.FLEX_STAKES_MIN_LOSE) getString(R.string.notification_limit_100_consequence_flex_lose, lose, pointsUnit)
                   else if (lose == Constants.FLEX_STAKES_MIN_LOSE) getString(R.string.notification_limit_100_consequence_flex_no_lose) // Check against MIN_LOSE (0)
                   else getString(R.string.notification_limit_100_consequence_fallback) // Fallback if lose is null or < 0 (shouldn't happen)
               }
               else -> getString(R.string.notification_limit_100_consequence_fallback) // Fallback for other phases
           }


           // Construct the final message using stringResource
           val message = getString(R.string.notification_limit_100_message, goalMinutes, targetAppName, pointConsequence)


           // Use constant for notification ID
           showInterventionNotification(USAGE_LIMIT_100_NOTIFICATION_ID, title, message)
           warnedAt100Percent = true // Set flag so it only shows once per day
           Log.i(TAG,"Showing 100% usage limit notification with consequence.")
       }
   }


} // End of UsageTrackingService class
</UsageTrackingService>



<AuthScreens>
package com.niyaz.zario.ui.screens


// import com.example.studyuiapp.data.state.StudyStateManager // No longer directly needed here
import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseAuthInvalidCredentialsException
import com.google.firebase.auth.FirebaseAuthInvalidUserException
import com.google.firebase.auth.FirebaseAuthUserCollisionException
import com.google.firebase.auth.ktx.auth
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.R
import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppDatabase
import com.niyaz.zario.data.repository.StudyRepository
import com.niyaz.zario.data.repository.StudyRepositoryImpl
import com.niyaz.zario.navigation.Screen
import com.niyaz.zario.utils.Constants
import com.niyaz.zario.utils.StudyStateManager
import kotlinx.coroutines.launch
import java.util.Calendar




@Composable
fun AuthDecisionScreen(navController: NavController) {
   Column(
       modifier = Modifier.fillMaxSize().padding(16.dp),
       verticalArrangement = Arrangement.Center,
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       // Correct: stringResource called within Composable context
       Text(stringResource(R.string.auth_decision_welcome))
       Spacer(modifier = Modifier.height(32.dp))
       Button(onClick = { navController.navigate(Screen.Login.route) }) {
           // Correct: stringResource called within Composable context (Button content lambda)
           Text(stringResource(R.string.auth_decision_login_button))
       }
       Spacer(modifier = Modifier.height(16.dp))
       Button(onClick = { navController.navigate(Screen.Register.route) }) {
           // Correct: stringResource called within Composable context
           Text(stringResource(R.string.auth_decision_register_button))
       }
   }
}


@Composable
fun LoginScreen(navController: NavController) {
   // --- State ---
   var email by rememberSaveable { mutableStateOf("") }
   var password by rememberSaveable { mutableStateOf("") }
   var emailError by remember { mutableStateOf<String?>(null) }
   var passwordError by remember { mutableStateOf<String?>(null) }
   var generalError by remember { mutableStateOf<String?>(null) }
   var isLoading by remember { mutableStateOf(false) }
   // --- NEW State for Reset Dialog ---
   var showResetDialog by remember { mutableStateOf(false) }
   var resetEmail by rememberSaveable { mutableStateOf("") } // Pre-fill with login email if available
   var resetEmailError by remember { mutableStateOf<String?>(null) }
   var isResetting by remember { mutableStateOf(false) }
   // --- End Reset Dialog State ---


   val context = LocalContext.current // Get context for non-composable string access
   val auth: FirebaseAuth = Firebase.auth
   val coroutineScope = rememberCoroutineScope()


   // --- NEW: Reset Password Dialog ---
   if (showResetDialog) {
       AlertDialog(
           onDismissRequest = { if (!isResetting) showResetDialog = false },
           // Correct: stringResource called within Composable context (title lambda)
           title = { Text(stringResource(R.string.login_reset_dialog_title)) },
           text = {
               Column {
                   // Correct: stringResource called within Composable context
                   Text(stringResource(R.string.login_reset_dialog_message))
                   Spacer(modifier = Modifier.height(8.dp))
                   OutlinedTextField(
                       value = resetEmail,
                       onValueChange = { resetEmail = it; resetEmailError = null },
                       // Correct: stringResource called within Composable context (label lambda)
                       label = { Text(stringResource(R.string.email_address_label)) },
                       keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                       singleLine = true,
                       isError = resetEmailError != null,
                       enabled = !isResetting
                   )
                   if (resetEmailError != null) {
                       // Error message state is just a String, display it directly
                       Text(resetEmailError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
                   }
               }
           },
           confirmButton = {
               Button(
                   onClick = {
                       // Correct: Use context.getString in non-composable onClick lambda
                       if (resetEmail.isBlank() || !android.util.Patterns.EMAIL_ADDRESS.matcher(resetEmail).matches()) {
                           resetEmailError = context.getString(R.string.validation_invalid_email)
                       } else {
                           resetEmailError = null
                           isResetting = true
                           auth.sendPasswordResetEmail(resetEmail)
                               .addOnCompleteListener { task ->
                                   isResetting = false
                                   if (task.isSuccessful) {
                                       Log.d("LoginScreen", "Password reset email sent to $resetEmail")
                                       // Correct: Use context.getString for Toast message
                                       Toast.makeText(context, context.getString(R.string.login_reset_dialog_toast_success), Toast.LENGTH_LONG).show()
                                       showResetDialog = false
                                   } else {
                                       Log.w("LoginScreen", "sendPasswordResetEmail failure", task.exception)
                                       // Correct: Use context.getString in non-composable listener lambda
                                       resetEmailError = context.getString(R.string.login_reset_dialog_toast_failure)
                                   }
                               }
                       }
                   },
                   enabled = !isResetting
               ) {
                   if(isResetting) {
                       CircularProgressIndicator(modifier = Modifier.size(24.dp), strokeWidth = 2.dp)
                   } else {
                       // Correct: stringResource called within Composable context (Button content lambda)
                       Text(stringResource(R.string.login_reset_dialog_send_button))
                   }
               }
           },
           dismissButton = {
               TextButton(onClick = { if (!isResetting) showResetDialog = false }, enabled = !isResetting) {
                   // Correct: stringResource called within Composable context
                   Text(stringResource(R.string.cancel))
               }
           }
       )
   }
   // --- End Reset Password Dialog ---


   Column(
       modifier = Modifier
           .fillMaxSize()
           .padding(16.dp)
           .verticalScroll(rememberScrollState()),
       verticalArrangement = Arrangement.Center,
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       // Correct: stringResource called within Composable context
       Text(stringResource(R.string.login_title), style = MaterialTheme.typography.headlineMedium)
       Spacer(modifier = Modifier.height(24.dp))


       // --- Email Field ---
       OutlinedTextField(
           value = email,
           onValueChange = { email = it.trim(); emailError = null; generalError = null },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.email_address_label)) },
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
           singleLine = true,
           isError = emailError != null || generalError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (emailError != null) {
           // Error message state is just a String, display it directly
           Text(emailError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Password Field ---
       OutlinedTextField(
           value = password,
           onValueChange = { password = it; passwordError = null; generalError = null },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.password_label)) },
           visualTransformation = PasswordVisualTransformation(),
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
           singleLine = true,
           isError = passwordError != null || generalError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (passwordError != null) {
           // Error message state is just a String, display it directly
           Text(passwordError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(8.dp))


       // --- Forgot Password Button ---
       TextButton(
           onClick = {
               resetEmail = if (android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) email else ""
               resetEmailError = null
               showResetDialog = true
           },
           modifier = Modifier.align(Alignment.End),
           enabled = !isLoading && !isResetting
       ) {
           // Correct: stringResource called within Composable context
           Text(stringResource(R.string.login_forgot_password_button))
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Display General Login Error ---
       if (generalError != null) {
           // Error message state is just a String, display it directly
           Text(generalError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
           Spacer(modifier = Modifier.height(8.dp))
       }


       // --- Login Button ---
       Button(
           onClick = {
               generalError = null // Clear previous errors
               // --- Basic Validation ---
               var isValid = true
               // Correct: Use context.getString in non-composable onClick lambda
               if (email.isBlank() || !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) { emailError = context.getString(R.string.validation_invalid_email); isValid = false } else { emailError = null }
               if (password.isBlank()) { passwordError = context.getString(R.string.validation_password_empty); isValid = false } else { passwordError = null }
               // --- End Validation ---


               if (isValid) {
                   isLoading = true
                   Log.d("LoginScreen", "Client validation passed. Attempting Firebase login for: $email")


                   // --- Firebase Login Logic ---
                   auth.signInWithEmailAndPassword(email, password)
                       .addOnCompleteListener { task ->
                           if (task.isSuccessful) {
                               Log.d("LoginScreen", "signInWithEmail:success")
                               val user = auth.currentUser
                               val userId = user?.uid


                               if (userId != null) {
                                   // --- Fetch State From Firestore ---
                                   coroutineScope.launch { // Launch fetch in coroutine scope
                                       val fetchSuccess = StudyStateManager.fetchAndSaveStateFromFirestore(context, userId)
                                       isLoading = false // Hide loading after fetch attempt


                                       if (fetchSuccess) {
                                           // Navigate to home only after state is fetched and saved
                                           navController.navigate(Screen.Home.route) {
                                               popUpTo(Screen.AuthDecision.route) { inclusive = true }
                                               launchSingleTop = true
                                           }
                                       } else {
                                           // Handle case where Firestore data couldn't be fetched/found
                                           // Correct: Use context.getString in non-composable coroutine scope
                                           generalError = context.getString(R.string.login_error_load_study_data)
                                           // Log out the user since their state isn't usable
                                           auth.signOut()
                                       }
                                   }
                                   // Note: isLoading = false is now inside the coroutine scope after fetch


                               } else {
                                   // Should not happen if task successful, but handle defensively
                                   Log.w("LoginScreen", "Sign in successful but user or UID is null.")
                                   // Correct: Use context.getString in non-composable listener lambda
                                   generalError = context.getString(R.string.login_error_session_verification)
                                   isLoading = false
                               }


                           } else {
                               // If sign in fails
                               Log.w("LoginScreen", "signInWithEmail:failure", task.exception)
                               // Correct: Use context.getString in non-composable listener lambda
                               generalError = when (task.exception) {
                                   is FirebaseAuthInvalidUserException, // User doesn't exist
                                   is FirebaseAuthInvalidCredentialsException -> // Wrong password
                                       context.getString(R.string.login_error_invalid_credentials)
                                   else -> context.getString(R.string.error_generic_message) // Generic fallback
                               }
                               isLoading = false
                           }
                       }
                   // --- End Firebase Login Logic ---


               } else {
                   Log.w("LoginScreen", "Client validation failed.")
                   isLoading = false // Ensure loading is off
               }
           },
           enabled = !isLoading,
           modifier = Modifier.fillMaxWidth()
       ) {
           if (isLoading) {
               CircularProgressIndicator(modifier = Modifier.size(24.dp), strokeWidth = 2.dp)
           } else {
               // Correct: stringResource called within Composable context
               Text(stringResource(R.string.login_button))
           }
       }
       Spacer(modifier = Modifier.height(8.dp))


       // --- Back Button ---
       TextButton(onClick = { if (!isLoading) navController.popBackStack() }, enabled = !isLoading) {
           // Correct: stringResource called within Composable context
           Text(stringResource(R.string.back))
       }
   }
}




@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RegisterScreen(navController: NavController) {
   // State variables
   var yearOfBirth by rememberSaveable { mutableStateOf("") }
   var gender by rememberSaveable { mutableStateOf("") }
   var email by rememberSaveable { mutableStateOf("") }
   var password by rememberSaveable { mutableStateOf("") }
   var confirmPassword by rememberSaveable { mutableStateOf("") }
   var yearError by remember { mutableStateOf<String?>(null) }
   var genderError by remember { mutableStateOf<String?>(null) }
   var emailError by remember { mutableStateOf<String?>(null) }
   var passwordError by remember { mutableStateOf<String?>(null) }
   var confirmPasswordError by remember { mutableStateOf<String?>(null) }
   var genderExpanded by remember { mutableStateOf(false) }
   var isLoading by remember { mutableStateOf(false) }
   var generalError by remember { mutableStateOf<String?>(null) } // Added for error display


   val context = LocalContext.current // Get context
   val auth: FirebaseAuth = Firebase.auth
   // Removed direct firestore instance: val firestore: FirebaseFirestore = Firebase.firestore
   val coroutineScope = rememberCoroutineScope()


   // --- FIX: Instantiate Repository directly within the Composable ---
   val repository: StudyRepository = remember { // Use remember to avoid recreating on recomposition
       StudyRepositoryImpl(
           context = context.applicationContext, // Use application context
           // Assuming AppDatabase has a static getDatabase method
           usageStatDao = AppDatabase.getDatabase(context.applicationContext).usageStatDao(),
           firestore = Firebase.firestore // Pass Firestore instance to Repository
       )
   }
   // --- End Repository Instantiation ---




   // Define gender options list using resources
   // Correct: stringResource called within Composable context during initialization
   val genderOptions = listOf(
       stringResource(R.string.register_gender_male),
       stringResource(R.string.register_gender_female),
       stringResource(R.string.register_gender_other),
       stringResource(R.string.register_gender_prefer_not_say)
   )




   Column(
       modifier = Modifier
           .fillMaxSize()
           .padding(16.dp)
           .verticalScroll(rememberScrollState()), // Make column scrollable
       verticalArrangement = Arrangement.Center,
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       // Correct: stringResource called within Composable context
       Text(stringResource(R.string.register_title), style = MaterialTheme.typography.headlineMedium)
       Spacer(modifier = Modifier.height(24.dp))


       // --- Year of Birth Field ---
       OutlinedTextField(
           value = yearOfBirth,
           onValueChange = {
               if (it.all { char -> char.isDigit() } && it.length <= 4) {
                   yearOfBirth = it
                   yearError = null // Clear error state
               }
           },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.register_yob_label)) },
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
           singleLine = true,
           isError = yearError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (yearError != null) {
           // Error message state is just a String, display it directly
           Text(yearError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Gender Dropdown ---
       ExposedDropdownMenuBox(
           expanded = genderExpanded,
           onExpandedChange = { genderExpanded = !genderExpanded },
           modifier = Modifier.fillMaxWidth()
       ) {
           OutlinedTextField(
               value = gender, // Display the selected gender
               onValueChange = { }, // Not directly changeable
               readOnly = true,
               // Correct: stringResource called within Composable context (label lambda)
               label = { Text(stringResource(R.string.register_gender_label)) },
               trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = genderExpanded) },
               modifier = Modifier
                   .menuAnchor() // Important for positioning the dropdown
                   .fillMaxWidth(),
               isError = genderError != null
           )
           ExposedDropdownMenu(
               expanded = genderExpanded,
               onDismissRequest = { genderExpanded = false }
           ) {
               // genderOptions already contains localized strings
               genderOptions.forEach { selectionOption ->
                   DropdownMenuItem(
                       text = { Text(selectionOption) },
                       onClick = {
                           gender = selectionOption
                           genderExpanded = false
                           genderError = null // Clear error state
                       }
                   )
               }
           }
       }
       if (genderError != null) {
           // Error message state is just a String, display it directly
           Text(genderError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Email Field ---
       OutlinedTextField(
           value = email,
           onValueChange = {
               email = it.trim() // Trim input
               emailError = null // Clear error state
           },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.email_address_label)) },
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
           singleLine = true,
           isError = emailError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (emailError != null) {
           // Error message state is just a String, display it directly
           Text(emailError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Password Field ---
       OutlinedTextField(
           value = password,
           onValueChange = {
               password = it
               passwordError = null // Clear error state
           },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.password_label)) },
           visualTransformation = PasswordVisualTransformation(),
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
           singleLine = true,
           isError = passwordError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (passwordError != null) {
           // Error message state is just a String, display it directly
           Text(passwordError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // --- Confirm Password Field ---
       OutlinedTextField(
           value = confirmPassword,
           onValueChange = {
               confirmPassword = it
               confirmPasswordError = null // Clear error state
           },
           // Correct: stringResource called within Composable context (label lambda)
           label = { Text(stringResource(R.string.register_confirm_password_label)) },
           visualTransformation = PasswordVisualTransformation(),
           keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
           singleLine = true,
           isError = confirmPasswordError != null,
           modifier = Modifier.fillMaxWidth()
       )
       if (confirmPasswordError != null) {
           // Error message state is just a String, display it directly
           Text(confirmPasswordError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
       }
       Spacer(modifier = Modifier.height(16.dp))


       // Display general Firebase error message
       if (generalError != null) {
           // Error message state is just a String, display it directly
           Text(generalError!!, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
           Spacer(modifier = Modifier.height(8.dp))
       }


       // --- Register Button ---
       Button(
           onClick = {
               generalError = null // Reset general error on new attempt
               // --- Basic Validation ---
               var isValid = true // Reset validity check
               val currentYear = Calendar.getInstance().get(Calendar.YEAR)
               val birthYear = yearOfBirth.toIntOrNull()
               // Correct: Use context.getString in non-composable onClick lambda
               // Use constant for min birth year
               if (yearOfBirth.isBlank() || birthYear == null || birthYear < Constants.MIN_BIRTH_YEAR || birthYear > currentYear) { yearError = context.getString(R.string.register_validation_invalid_year); isValid = false } else { yearError = null }
               if (gender.isBlank()) { genderError = context.getString(R.string.register_validation_gender_required); isValid = false } else { genderError = null }
               if (email.isBlank() || !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) { emailError = context.getString(R.string.validation_invalid_email); isValid = false } else { emailError = null }
               // Use constant for min password length
               if (password.length < Constants.MIN_PASSWORD_LENGTH) { passwordError = context.getString(R.string.register_validation_password_length); isValid = false } else { passwordError = null }
               if (confirmPassword != password) { confirmPasswordError = context.getString(R.string.register_validation_password_mismatch); isValid = false } else { confirmPasswordError = null }
               // --- End Basic Validation ---


               if (isValid) {
                   isLoading = true
                   Log.i("RegisterScreen", "Client validation passed. Attempting Firebase registration for: $email")


                   // --- Firebase Registration Logic ---
                   auth.createUserWithEmailAndPassword(email, password)
                       .addOnCompleteListener { task ->
                           if (task.isSuccessful) {
                               // Sign in success
                               Log.d("RegisterScreen", "createUserWithEmail:success")
                               val user = auth.currentUser
                               val userId = user?.uid


                               if (userId != null) {
                                   // --- Call Repository Method ---
                                   val studyStartTime = System.currentTimeMillis() // Defined earlier in original code
                                   val assignedCondition = listOf(StudyPhase.INTERVENTION_CONTROL, StudyPhase.INTERVENTION_DEPOSIT, StudyPhase.INTERVENTION_FLEXIBLE).random() // Defined earlier


                                   coroutineScope.launch { // Keep coroutineScope for suspend function call
                                       try {
                                           // Prepare the profile data map (using constants) - Defined ONCE here
                                           val userData = hashMapOf<String, Any?>(
                                               Constants.FIRESTORE_FIELD_EMAIL to email,
                                               Constants.FIRESTORE_FIELD_YOB to yearOfBirth.toIntOrNull(),
                                               Constants.FIRESTORE_FIELD_GENDER to gender, // Keep localized string value
                                               Constants.FIRESTORE_FIELD_REG_TIMESTAMP to studyStartTime,
                                               Constants.FIRESTORE_FIELD_STUDY_PHASE to StudyPhase.BASELINE.name, // Value is enum name
                                               Constants.FIRESTORE_FIELD_STUDY_CONDITION to assignedCondition.name, // Value is enum name
                                               Constants.FIRESTORE_FIELD_STUDY_START_TIMESTAMP to studyStartTime,
                                               Constants.FIRESTORE_FIELD_POINTS_BALANCE to Constants.INITIAL_POINTS.toLong(), // Value uses Constant
                                               Constants.FIRESTORE_FIELD_TARGET_APP to null, // Key uses Constant
                                               Constants.FIRESTORE_FIELD_DAILY_GOAL to null, // Key uses Constant
                                               Constants.FIRESTORE_FIELD_FLEX_EARN to null, // Key uses Constant
                                               Constants.FIRESTORE_FIELD_FLEX_LOSE to null // Key uses Constant
                                           )


                                           // *** USE THE INSTANTIATED REPOSITORY ***
                                           // No direct Firestore write here anymore
                                           val initResult = repository.initializeNewUser(
                                               userId = userId,
                                               userProfileData = userData,            // Map for Firestore
                                               initialPhase = StudyPhase.BASELINE,    // Enum for local state
                                               assignedCondition = assignedCondition, // Enum for local state
                                               initialPoints = Constants.INITIAL_POINTS, // Int for local state
                                               registrationTimestamp = studyStartTime // Long for local state
                                           )


                                           if (initResult.isSuccess) {
                                               Log.d("RegisterScreen", "New user initialized successfully via Repository.")
                                               isLoading = false
                                               // Navigate to Home
                                               navController.navigate(Screen.Home.route) {
                                                   popUpTo(Screen.AuthDecision.route) { inclusive = true }
                                                   launchSingleTop = true
                                               }
                                           } else {
                                               // Repository method failed (Firestore or Local save)
                                               Log.w("RegisterScreen", "Error initializing user via Repository", initResult.exceptionOrNull())
                                               generalError = context.getString(R.string.register_error_profile_save)
                                               // Attempt to delete the partially created Auth user for cleanup
                                               user?.delete()?.addOnCompleteListener { deleteTask -> // Use non-null user reference
                                                   Log.d("RegisterScreen", "Attempted to delete auth user after repository init failure. Success: ${deleteTask.isSuccessful}")
                                               }
                                               isLoading = false
                                           }


                                       } catch (e: Exception) {
                                           // Catch potential exceptions from repository access itself or other logic
                                           Log.e("RegisterScreen", "Error during registration repository interaction", e)
                                           generalError = context.getString(R.string.register_error_profile_save)
                                           user?.delete()?.addOnCompleteListener { deleteTask -> // Use non-null user reference
                                               Log.d("RegisterScreen", "Attempted to delete auth user after general exception. Success: ${deleteTask.isSuccessful}")
                                           }
                                           isLoading = false
                                       }
                                   } // End coroutineScope.launch


                               } else { // Handle userId == null
                                   Log.w("RegisterScreen", "User creation task successful but user or UID is null.")
                                   // Correct: Use context.getString in non-composable listener lambda
                                   generalError = context.getString(R.string.register_error_user_id)
                                   isLoading = false
                                   // Consider attempting user deletion here too if needed, though auth task succeeded.
                               }


                           } else { // Handle task failure (Firebase Auth createUser failed)
                               // If sign in fails
                               Log.w("RegisterScreen", "createUserWithEmail:failure", task.exception)
                               // Correct: Use context.getString in non-composable listener lambda
                               generalError = when (task.exception) {
                                   is FirebaseAuthUserCollisionException -> context.getString(R.string.register_error_email_collision)
                                   // Add more specific FirebaseAuthException checks if needed
                                   else -> context.getString(R.string.error_generic_message) // Generic fallback
                               }
                               isLoading = false // Set loading false on auth failure
                           }
                       } // End addOnCompleteListener
                   // --- End Firebase Registration Logic ---


               } else { // Handle isValid == false
                   Log.w("RegisterScreen", "Client validation failed.")
                   // Ensure loading indicator stops if validation fails before attempting registration
                   isLoading = false
               }
           }, // End onClick lambda
           enabled = !isLoading,
           modifier = Modifier.fillMaxWidth()
       ) {
           if (isLoading) {
               CircularProgressIndicator(modifier = Modifier.size(24.dp), strokeWidth = 2.dp)
           } else {
               // Correct: stringResource called within Composable context
               Text(stringResource(R.string.register_button))
           }
       }
       Spacer(modifier = Modifier.height(8.dp))


       // --- Back Button ---
       TextButton(onClick = { if (!isLoading) navController.popBackStack() }, enabled = !isLoading) {
           // Correct: stringResource called within Composable context
           Text(stringResource(R.string.back))
       }
   } // End Column
}


</AuthScreens>


<MainScreen>
package com.niyaz.zario.ui.screens // Ensure correct package


import android.Manifest
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.TextLayoutResult
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.rememberTextMeasurer
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.TextUnit
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import androidx.core.content.ContextCompat.startActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import coil.compose.rememberAsyncImagePainter
import com.google.firebase.auth.ktx.auth
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.R
import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppDatabase
import com.niyaz.zario.data.model.AppBaselineInfo
import com.niyaz.zario.data.repository.StudyRepository
import com.niyaz.zario.data.repository.StudyRepositoryImpl
import com.niyaz.zario.navigation.Screen
import com.niyaz.zario.services.UsageTrackingService
import com.niyaz.zario.ui.viewmodels.HomeViewModel
import com.niyaz.zario.ui.viewmodels.HomeViewModel.GoalSettingUiState
import com.niyaz.zario.utils.AppInfoHelper
import com.niyaz.zario.utils.Constants
import com.niyaz.zario.utils.PermissionsUtils
import com.niyaz.zario.utils.StudyStateManager
import com.niyaz.zario.workers.DailyCheckWorker
import com.niyaz.zario.workers.FirestoreSyncWorker
import java.util.concurrent.TimeUnit
import kotlin.math.max




@Composable
fun HomeScreen(navController: NavController) { // Inject ViewModel
   val context = LocalContext.current
   val lifecycleOwner = LocalLifecycleOwner.current


   // --- Instantiate Repository (Similar to AuthScreens) ---
   // In a larger app, use DI (Hilt/Koin) to provide the repository here.
   val repository: StudyRepository = remember {
       StudyRepositoryImpl(
           context = context.applicationContext,
           usageStatDao = AppDatabase.getDatabase(context.applicationContext).usageStatDao()
       )
   }


   // --- Instantiate ViewModel using the Factory ---
   val homeViewModel: HomeViewModel = viewModel(
       factory = HomeViewModel.provideFactory(repository = repository)
   )
   // --- End ViewModel Instantiation ---




   // --- Collect State from ViewModel ---
   val todayUsageMs by homeViewModel.todayUsageMs.collectAsState()
   val goalSettingState by homeViewModel.goalSettingState.collectAsState()
   val baselineAppList by homeViewModel.baselineAppList.collectAsState()
   val suggestedApp by homeViewModel.suggestedApp.collectAsState()
   val hourlyData by homeViewModel.hourlyUsageData.collectAsState() // Collect hourly data


   // --- Local State (Permissions, Phase, Stakes) ---
   var hasUsageStatsPermission by remember { mutableStateOf(PermissionsUtils.hasUsageStatsPermission(context)) }
   var hasNotificationPermission by remember {
       mutableStateOf(
           if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) true
           else ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == android.content.pm.PackageManager.PERMISSION_GRANTED
       )
   }
   // Track current phase locally, but rely on ViewModel/StateManager for source of truth
   var currentStudyPhase by remember { mutableStateOf(StudyStateManager.getStudyPhase(context)) }
   // Track flex stakes locally
   var flexibleStakes by remember {
       mutableStateOf(
           if (StudyStateManager.getStudyPhase(context) == StudyPhase.INTERVENTION_FLEXIBLE) {
               StudyStateManager.getFlexStakes(context)
           } else {
               Pair(null, null) // Default to null if not in flex phase initially
           }
       )
   }
   // --- End Local State ---




   // --- Permission Launchers --- (Unchanged)
   val notificationPermissionLauncher = rememberLauncherForActivityResult(
       contract = ActivityResultContracts.RequestPermission()
   ) { isGranted: Boolean ->
       Log.d("HomeScreen", "Notification permission granted: $isGranted")
       hasNotificationPermission = isGranted
   }


// --- Schedule Daily AND Sync Workers ---
   LaunchedEffect(currentStudyPhase) { // Trigger based on phase change
       val workManager = WorkManager.getInstance(context)


       // --- Daily Check Worker (Only during Intervention) ---
       if (currentStudyPhase.name.startsWith("INTERVENTION")) { // Condition remains same
           Log.d("HomeScreen", "Intervention phase active. Scheduling DailyCheckWorker.")
           // Use Constant for worker interval
           val dailyCheckRequest = PeriodicWorkRequestBuilder<DailyCheckWorker>(
               Constants.DEFAULT_CHECK_WORKER_INTERVAL_HOURS, // Example: Use a constant if defined (e.g., 24)
               TimeUnit.HOURS
           ).build() // Add constraints if needed (e.g., charging)
           // Use Constant for worker name
           workManager.enqueueUniquePeriodicWork(
               Constants.DAILY_CHECK_WORKER_NAME,
               ExistingPeriodicWorkPolicy.KEEP, // Keep existing worker if running
               dailyCheckRequest
           )
           // Use Constant for worker name
           Log.i("HomeScreen", "DailyCheckWorker enqueued/verified with name: ${Constants.DAILY_CHECK_WORKER_NAME}") // Use Constant
       } else { // If not in intervention, cancel DailyCheckWorker
           Log.d("HomeScreen", "Not in intervention phase. Cancelling DailyCheckWorker.")
           // Use Constant for worker name
           workManager.cancelUniqueWork(Constants.DAILY_CHECK_WORKER_NAME) // Use Constant
       }


       // --- Firestore Sync Worker (Runs during Baseline AND Intervention) ---
       // Schedule if user has logged in and tracking is potentially active
       val shouldRunSync = currentStudyPhase == StudyPhase.BASELINE || currentStudyPhase.name.startsWith("INTERVENTION")
       if (shouldRunSync) {
           Log.d("HomeScreen", "Baseline or Intervention phase active. Scheduling FirestoreSyncWorker.")
           val syncRequest = PeriodicWorkRequestBuilder<FirestoreSyncWorker>(
               FirestoreSyncWorker.REPEAT_INTERVAL_HOURS, // Use interval from Worker companion
               TimeUnit.HOURS
           )
               .setConstraints(FirestoreSyncWorker.WORKER_CONSTRAINTS) // Use constraints from Worker companion
               .build()


           workManager.enqueueUniquePeriodicWork(
               FirestoreSyncWorker.UNIQUE_WORK_NAME, // Use unique name from Worker companion
               ExistingPeriodicWorkPolicy.KEEP, // Keep existing worker if already scheduled
               syncRequest
           )
           Log.i("HomeScreen", "FirestoreSyncWorker enqueued/verified with name: ${FirestoreSyncWorker.UNIQUE_WORK_NAME}")
       } else { // Cancel if not in Baseline or Intervention (e.g., Completed, Registered)
           Log.d("HomeScreen", "Not in Baseline or Intervention phase. Cancelling FirestoreSyncWorker.")
           workManager.cancelUniqueWork(FirestoreSyncWorker.UNIQUE_WORK_NAME)
       }
   }


   // --- Re-check permissions, phase, AND stakes on Resume --- (Unchanged)
   DisposableEffect(lifecycleOwner) {
       val observer = LifecycleEventObserver { _, event ->
           if (event == Lifecycle.Event.ON_RESUME) {
               Log.d("HomeScreen", "ON_RESUME: Re-checking state.")
               hasUsageStatsPermission = PermissionsUtils.hasUsageStatsPermission(context)
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                   hasNotificationPermission = ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == android.content.pm.PackageManager.PERMISSION_GRANTED
               }
               // Update local phase based on potentially changed persisted state
               currentStudyPhase = StudyStateManager.getStudyPhase(context)
               if (currentStudyPhase == StudyPhase.INTERVENTION_FLEXIBLE) {
                   flexibleStakes = StudyStateManager.getFlexStakes(context)
               }
               // If resumed into Goal Setting phase, ensure baseline data is loaded if needed
               if (currentStudyPhase == StudyPhase.GOAL_SETTING && goalSettingState == GoalSettingUiState.IDLE) {
                   homeViewModel.loadBaselineData()
               }
               // Refresh target app in ViewModel on resume in case it changed externally (less likely but safe)
               if (currentStudyPhase.name.startsWith("INTERVENTION")) {
                   homeViewModel.refreshTargetApp()
               }
           }
       }
       lifecycleOwner.lifecycle.addObserver(observer)
       onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
   }


   // --- Start/Stop Service Effect --- (Unchanged)
   LaunchedEffect(hasUsageStatsPermission, hasNotificationPermission, currentStudyPhase) {
       val shouldBeTracking = hasUsageStatsPermission && hasNotificationPermission &&
               (currentStudyPhase == StudyPhase.BASELINE || currentStudyPhase.name.startsWith("INTERVENTION"))
       val serviceIntent = Intent(context, UsageTrackingService::class.java)
       if (shouldBeTracking) {
           Log.d("HomeScreen", "Conditions met for tracking. Ensuring service is started.")
           try {
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                   context.startForegroundService(serviceIntent)
               } else {
                   context.startService(serviceIntent)
               }
               Log.d("HomeScreen", "Service start command issued.")
           } catch (e: Exception) {
               Log.e("HomeScreen", "Failed to start UsageTrackingService: ${e.message}", e)
           }
       } else {
           Log.d("HomeScreen", "Conditions not met for tracking. Ensuring service is stopped.")
           try {
               context.stopService(serviceIntent)
               Log.d("HomeScreen", "Service stop command issued.")
           } catch (e: Exception) {
               Log.e("HomeScreen", "Error stopping service: ${e.message}")
           }
       }
   }


// --- UI ---
   Column(
       modifier = Modifier
           .fillMaxSize()
           .padding(16.dp),
       verticalArrangement = Arrangement.Top, // Changed to Top for Goal Setting flow
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       // Determine if we need to show prompts or the main content
       val showPermissionPrompts = !hasUsageStatsPermission || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !hasNotificationPermission)
       val showActiveContent = !showPermissionPrompts // Only show main content if permissions are OK


       if (showActiveContent) {
           // --- Display Active Content (Phase Dependent) ---
           // Show Phase always at the top for context
           Text(
               text = stringResource(R.string.home_study_phase_label, currentStudyPhase.name), // Use stringResource
               style = MaterialTheme.typography.titleMedium,
               modifier = Modifier.padding(bottom = 16.dp) // Add padding below phase
           )


           // Check if Flexible Deposit stakes need setup
           val needsFlexSetup = currentStudyPhase == StudyPhase.INTERVENTION_FLEXIBLE && flexibleStakes.first == null


           if (needsFlexSetup) {
               // --- Show Flexible Deposit Setup UI --- (Composable updated below)
               FlexibleDepositSetupUI { earn, lose ->
                   // Callback when user confirms stakes
                   Log.d("HomeScreen", "Flexible Stakes Confirmed: Earn=$earn, Lose=$lose")
                   // Save stakes locally and to Firestore
                   StudyStateManager.saveFlexStakes(context, earn, lose)
                   val userId = StudyStateManager.getUserId(context)
                   if (userId != null) {
                       val firestore = Firebase.firestore
                       firestore.collection("users").document(userId)
                           .update(mapOf("flexPointsEarn" to earn.toLong(), "flexPointsLose" to lose.toLong())) // Save as Long
                           .addOnSuccessListener { Log.i("HomeScreen", "Firestore flex stakes updated.") }
                           .addOnFailureListener { e -> Log.e("HomeScreen", "Firestore flex stakes update failed.", e)}
                   }
                   // Update local state to hide setup UI and show main intervention UI
                   flexibleStakes = Pair(earn, lose)
               }
           } else {
               // --- Show Main Content based on Phase (when flex setup not needed or not flex condition) ---
               when (currentStudyPhase) {
                   StudyPhase.BASELINE -> { // --- Baseline UI (Text updated) ---
                       val startTime = StudyStateManager.getStudyStartTimestamp(context)
                       // Use Constant for baseline duration
                       val baselineDurationDays = Constants.BASELINE_DURATION_DAYS
                       val baselineDurationMs = TimeUnit.DAYS.toMillis(baselineDurationDays.toLong())


                       // --- Check for Baseline Completion ---
                       LaunchedEffect(startTime) {
                           if (startTime > 0) {
                               val timeElapsedMs = System.currentTimeMillis() - startTime
                               if (timeElapsedMs >= baselineDurationMs) {
                                   Log.i("HomeScreen", "Baseline period complete ($timeElapsedMs ms elapsed). Transitioning to GOAL_SETTING.")
                                   val goalSettingPhase = StudyPhase.GOAL_SETTING
                                   StudyStateManager.saveStudyPhase(context, goalSettingPhase)
                                   val userId = StudyStateManager.getUserId(context)
                                   if (userId != null) {
                                       Firebase.firestore.collection("users").document(userId)
                                           .update("studyPhase", goalSettingPhase.name)
                                           .addOnSuccessListener { Log.i("HomeScreen", "Firestore phase updated to GOAL_SETTING.") }
                                           .addOnFailureListener{ e -> Log.e("HomeScreen", "Firestore phase update failed.", e) }
                                   }
                                   currentStudyPhase = goalSettingPhase // Update local state immediately
                                   // Trigger baseline load in ViewModel now that phase changed
                                   homeViewModel.loadBaselineData()
                               } else {
                                   // Use the *variable* baselineDurationDays which holds the constant
                                   val daysRemaining = baselineDurationDays - TimeUnit.MILLISECONDS.toDays(timeElapsedMs)
                                   Log.d("HomeScreen","Baseline ongoing. Approx ${daysRemaining + 1} days remaining.") // +1 for current day
                               }
                           } else {
                               Log.w("HomeScreen", "Baseline phase active but start timestamp invalid ($startTime).")
                           }
                       }
                       // --- END Check ---


                       // --- Baseline UI Content --- (Text updated)
                       Text(stringResource(R.string.home_baseline_title), style = MaterialTheme.typography.headlineMedium) // Use stringResource
                       Spacer(modifier = Modifier.height(16.dp))
                       val daysElapsed = if (startTime > 0) TimeUnit.MILLISECONDS.toDays(System.currentTimeMillis() - startTime) else 0
                       // Use the *variable* baselineDurationDays which holds the constant
                       Text(stringResource(R.string.home_baseline_progress, daysElapsed + 1, baselineDurationDays), style = MaterialTheme.typography.bodyLarge) // Use stringResource
                       Spacer(modifier = Modifier.height(8.dp))
                       Text(
                           stringResource(R.string.home_baseline_message), // Use stringResource
                           style = MaterialTheme.typography.bodyMedium,
                           textAlign = TextAlign.Center
                       )
                       // --- End Baseline UI ---
                   } // End BASELINE case


                   // --- GOAL_SETTING IMPLEMENTATION (Text updated) ---
                   StudyPhase.GOAL_SETTING -> {
                       // Trigger load if entering this state and it's idle
                       LaunchedEffect(goalSettingState) {
                           if (goalSettingState == GoalSettingUiState.IDLE) {
                               homeViewModel.loadBaselineData()
                           }
                       }


                       // Display UI based on the ViewModel state
                       when (goalSettingState) {
                           GoalSettingUiState.IDLE, GoalSettingUiState.LOADING -> {
                               Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally) {
                                   Text(stringResource(R.string.goal_setting_loading_title), style = MaterialTheme.typography.titleLarge) // Use stringResource
                                   Spacer(modifier = Modifier.height(16.dp))
                                   CircularProgressIndicator()
                               }
                           }
                           GoalSettingUiState.ERROR -> {
                               Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally) {
                                   Text(stringResource(R.string.goal_setting_error_title), style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.error) // Use stringResource
                                   Spacer(modifier = Modifier.height(16.dp))
                                   Text(stringResource(R.string.goal_setting_error_message), textAlign = TextAlign.Center) // Use stringResource
                                   Spacer(modifier = Modifier.height(16.dp))
                                   Button(onClick = { homeViewModel.loadBaselineData() }) {
                                       Text(stringResource(R.string.goal_setting_retry_button)) // Use stringResource
                                   }
                               }
                           }
                           GoalSettingUiState.LOADED, GoalSettingUiState.SAVING -> {
                               // *** ADD hourlyUsageData from ViewModel ***
                               val hourlyData by homeViewModel.hourlyUsageData.collectAsState()


                               GoalSettingContent( // Call updated composable below
                                   isLoading = (goalSettingState == GoalSettingUiState.SAVING),
                                   suggestedApp = suggestedApp,
                                   baselineAppList = baselineAppList,
                                   hourlyUsageData = hourlyData, // Pass the data
                                   onConfirmGoal = { selectedApp ->
                                       homeViewModel.confirmGoalSelection(selectedApp)
                                   }
                               )
                           }
                           GoalSettingUiState.SAVED -> {
                               // This state is transient, the phase change should trigger recomposition
                               // to show the intervention UI. Can show a brief message if needed.
                               Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally) {
                                   Text(stringResource(R.string.goal_setting_saved_title), style = MaterialTheme.typography.titleLarge) // Use stringResource
                                   // Recomposition will happen automatically due to phase change
                               }
                           }
                       }
                   } // --- END GOAL_SETTING CASE ---




                   StudyPhase.INTERVENTION_CONTROL,
                   StudyPhase.INTERVENTION_DEPOSIT,
                   StudyPhase.INTERVENTION_FLEXIBLE -> { // --- Intervention UI (Text updated) ---
                       // --- Refactored Intervention UI based on Dashboard Sketch ---
                       val condition = StudyStateManager.getCondition(context) ?: currentStudyPhase
                       val points = StudyStateManager.getPointsBalance(context)
                       val targetAppPkg = StudyStateManager.getTargetApp(context)
                       val targetAppName = targetAppPkg?.let { AppInfoHelper.getAppName(context, it) } ?: "Your Target App"
                       val goalMs = StudyStateManager.getDailyGoalMs(context)
                       val (flexEarn, flexLose) = flexibleStakes


                       // *** FIX: Read colors from theme outside Canvas *** (Unchanged)
                       val primaryColor = MaterialTheme.colorScheme.primary
                       val trackColor = MaterialTheme.colorScheme.surfaceVariant // Use theme color for track


                       Column(
                           modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), // Add horizontal padding
                           horizontalAlignment = Alignment.CenterHorizontally
                       ) {
                           // 1. Dashboard Title
                           Text(
                               stringResource(R.string.dashboard_title), // Use stringResource
                               style = MaterialTheme.typography.headlineMedium, // Or headlineLarge if preferred
                               modifier = Modifier.padding(bottom = 16.dp)
                           )


                           // 2. Goal and Points Row
                           Row(
                               modifier = Modifier.fillMaxWidth().padding(bottom = 24.dp),
                               horizontalArrangement = Arrangement.SpaceAround, // Space out items
                               verticalAlignment = Alignment.Top // Align tops
                           ) {
                               // Goal Section
                               Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                   Text(stringResource(R.string.dashboard_goal_section_title), style = MaterialTheme.typography.titleMedium) // Use stringResource
                                   Spacer(modifier = Modifier.height(4.dp))
                                   Text(
                                       text = if (goalMs != null) stringResource(R.string.dashboard_goal_text, targetAppName, formatDuration(goalMs)) else stringResource(R.string.dashboard_goal_not_set), // Use stringResource
                                       style = MaterialTheme.typography.bodyMedium,
                                       textAlign = TextAlign.Center,
                                       modifier = Modifier.heightIn(min = 40.dp) // Ensure space
                                   )
                               }


                               // Points Section
                               Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                   Text(stringResource(R.string.dashboard_points_section_title), style = MaterialTheme.typography.titleMedium) // Use stringResource
                                   Spacer(modifier = Modifier.height(4.dp))
                                   Text(
                                       text = "$points", // Points value itself is dynamic
                                       style = MaterialTheme.typography.headlineMedium,
                                       fontWeight = FontWeight.Bold
                                   )
                               }
                           } // End Row Goal/Points


                           // --- Circular Progress for Time Left ---
                           if (goalMs != null && goalMs > 0) {
                               Box(
                                   contentAlignment = Alignment.Center,
                                   modifier = Modifier
                                       .fillMaxWidth(0.6f) // Control size relative to screen width
                                       .aspectRatio(1f) // Make it a square for a perfect circle
                                       .padding(bottom = 24.dp)
                               ) {
                                   val remainingMs = (goalMs - todayUsageMs).coerceAtLeast(0L)
                                   // Progress for indicator filling: 0.0 means full time left, 1.0 means no time left
                                   val progressFraction = (todayUsageMs.toFloat() / goalMs.toFloat()).coerceIn(0f, 1f)
                                   val sweepAngle = progressFraction * 360f
                                   val strokeWidth = 12.dp // Define stroke width
                                   // val primaryColor = MaterialTheme.colorScheme.primary // Read color from theme (already defined above)
                                   // val trackColor = MaterialTheme.colorScheme.surfaceVariant // Use theme color for track (already defined above)


                                   // *** REFACTORED: Draw both arcs in one Canvas *** (Unchanged)
                                   Canvas(modifier = Modifier.fillMaxSize()) {
                                       // Background track
                                       drawArc(
                                           color = trackColor,
                                           startAngle = -90f, // Start at the top
                                           sweepAngle = 360f, // Full circle
                                           useCenter = false,
                                           style = Stroke(width = strokeWidth.toPx())
                                       )
                                       // Foreground progress arc
                                       drawArc(
                                           color = primaryColor,
                                           startAngle = -90f, // Start at the top
                                           sweepAngle = sweepAngle, // Angle based on progress
                                           useCenter = false,
                                           style = Stroke(width = strokeWidth.toPx(), cap = StrokeCap.Round) // Round cap for progress
                                       )
                                   }
                                   // *** END REFACTORED Canvas ***


                                   // Text inside (Updated)
                                   Text(
                                       text = stringResource(R.string.dashboard_progress_text, formatDuration(remainingMs)), // Use stringResource
                                       style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                                       textAlign = TextAlign.Center
                                   )
                               }
                           } else {
                               // Placeholder if goal isn't set (Updated)
                               Text(stringResource(R.string.dashboard_progress_goal_not_set), style = MaterialTheme.typography.bodyLarge) // Use stringResource
                               Spacer(modifier = Modifier.height(24.dp))
                           } // End Circular Progress Box


                           // --- Daily Commitment Text ---
                           Text(stringResource(R.string.dashboard_commitment_section_title), style = MaterialTheme.typography.titleMedium) // Use stringResource
                           Spacer(modifier = Modifier.height(8.dp))
                           // Use a simple Card for background/border or just Text
                           Card(
                               modifier = Modifier.fillMaxWidth(),
                               elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
                           ) {
                               val commitmentText = when(condition) { // Use resolved stringResource results
                                   StudyPhase.INTERVENTION_CONTROL -> stringResource(R.string.dashboard_commitment_control)
                                   StudyPhase.INTERVENTION_DEPOSIT -> stringResource(R.string.dashboard_commitment_deposit)
                                   StudyPhase.INTERVENTION_FLEXIBLE -> stringResource(R.string.dashboard_commitment_flex, flexEarn ?: "-", flexLose ?: "-")
                                   else -> stringResource(R.string.dashboard_commitment_fallback)
                               }
                               Text(
                                   text = commitmentText, // Use resolved string
                                   style = MaterialTheme.typography.bodyLarge,
                                   textAlign = TextAlign.Center,
                                   modifier = Modifier.padding(16.dp).fillMaxWidth() // Padding inside card
                               )
                           } // End Card Commitment
                           Spacer(modifier = Modifier.height(16.dp)) // Space at the very bottom if needed


                       } // End Main Intervention Column
                   } // End INTERVENTION_* case


                   StudyPhase.REGISTERED -> { // --- Registered UI (Text updated) ---
                       Text(stringResource(R.string.home_registered_title), style = MaterialTheme.typography.headlineMedium) // Use stringResource
                       Spacer(modifier = Modifier.height(16.dp))
                       Text(stringResource(R.string.home_registered_message), textAlign = TextAlign.Center) // Use stringResource
                       Spacer(modifier = Modifier.height(16.dp))
                       Button(onClick = { currentStudyPhase = StudyStateManager.getStudyPhase(context) }) { Text(stringResource(R.string.home_registered_refresh_button)) } // Use stringResource
                   } // End REGISTERED case


                   StudyPhase.COMPLETED -> { // --- Completed UI (Text updated) ---
                       Text(stringResource(R.string.home_completed_title), style = MaterialTheme.typography.headlineMedium) // Use stringResource
                       Spacer(modifier = Modifier.height(16.dp))
                       Text(stringResource(R.string.home_completed_message), textAlign = TextAlign.Center) // Use stringResource
                   } // End COMPLETED case


               } // End of when(currentStudyPhase)


               // --- Logout Button (Positioned at bottom regardless of phase content) ---
               Spacer(modifier = Modifier.weight(1f)) // Pushes button to bottom
               Button(onClick = {
                   Log.d("HomeScreen", "Logout clicked.")
                   // 1. Stop services (if applicable)
                   try { context.stopService(Intent(context, UsageTrackingService::class.java)); Log.d("HomeScreen", "Service stop issued.") }
                   catch (e: Exception) { Log.e("HomeScreen", "Error stopping service.", e) }


                   // 2. Sign out from Firebase *FIRST*
                   Firebase.auth.signOut() // This call is now valid due to the import


                   // 3. Clear local study state *AFTER* Firebase sign out
                   StudyStateManager.clearStudyState(context) // Clear local prefs


                   // 4. Clear relevant ViewModel state
                   // Ensure homeViewModel instance is accessible in this scope
                   homeViewModel.refreshTargetApp() // Example: Clear target app in VM


                   // 5. Navigate *LAST*
                   navController.navigate(Screen.AuthDecision.route) {
                       popUpTo(Screen.Home.route) { inclusive = true } // Clear backstack up to Home
                       launchSingleTop = true
                   }
               }) { Text(stringResource(R.string.home_logout_button)) }
               Spacer(modifier = Modifier.height(16.dp)) // Padding below logout button
               // --- End Logout Button ---


           } // END of else block: if(needsFlexSetup)


       } else { // showPermissionPrompts is true
           // --- Display Permission Prompts --- (Text updated)
           Column( // Use a Column to center the prompts vertically
               modifier = Modifier.fillMaxSize(), // Take full space
               verticalArrangement = Arrangement.Center, // Center vertically
               horizontalAlignment = Alignment.CenterHorizontally
           ) {
               Text(
                   stringResource(R.string.home_permission_title), // Use stringResource
                   style = MaterialTheme.typography.headlineMedium,
                   textAlign = TextAlign.Center
               )
               Spacer(modifier = Modifier.height(16.dp))


               // Notification Permission Prompt
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !hasNotificationPermission) {
                   Text(
                       stringResource(R.string.home_permission_notification_message), // Use stringResource
                       style = MaterialTheme.typography.bodyLarge,
                       textAlign = TextAlign.Center
                   )
                   Spacer(modifier = Modifier.height(16.dp))
                   Button(onClick = { notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS) }) {
                       Text(stringResource(R.string.home_permission_notification_button)) // Use stringResource
                   }
                   Spacer(modifier = Modifier.height(24.dp))
               }


               // Usage Stats Permission Prompt
               if (!hasUsageStatsPermission) {
                   Text(
                       stringResource(R.string.home_permission_usage_message), // Use stringResource
                       style = MaterialTheme.typography.bodyLarge,
                       textAlign = TextAlign.Center
                   )
                   Spacer(modifier = Modifier.height(16.dp))
                   Button(onClick = {
                       try {
                           val intent = PermissionsUtils.getUsageStatsPermissionIntent()
                           startActivity(context, intent, null)
                       } catch (e: Exception) {
                           Log.e("HomeScreen", "Error opening Usage Access Settings: ${e.message}", e)
                       }
                   }) {
                       Text(stringResource(R.string.home_permission_usage_button)) // Use stringResource
                   }
                   Spacer(modifier = Modifier.height(16.dp))
                   Button(onClick = {
                       hasUsageStatsPermission = PermissionsUtils.hasUsageStatsPermission(context)
                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                           hasNotificationPermission = ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == android.content.pm.PackageManager.PERMISSION_GRANTED
                       }
                       Log.d("HomeScreen", "Manual permission check results - UsageStats: $hasUsageStatsPermission, Notification: $hasNotificationPermission")
                   }) {
                       Text(stringResource(R.string.home_permission_check_button)) // Use stringResource
                   }
               }


               Spacer(modifier = Modifier.height(32.dp))


               // Logout Button (Available even if permissions aren't granted)
               Button(onClick = {
                   Log.d("HomeScreen", "Logout clicked while permissions pending.")
                   StudyStateManager.clearStudyState(context)
                   homeViewModel.refreshTargetApp() // Clear VM state too
                   navController.navigate(Screen.AuthDecision.route) { popUpTo(Screen.Home.route) { inclusive = true }; launchSingleTop = true }
               }) { Text(stringResource(R.string.home_logout_button)) } // Use stringResource
           } // End Column for Prompts
       } // End of else block (showPermissionPrompts)
   } // End of Main Column
}




// --- GoalSettingContent Composable (Ensure hourlyUsageData usage, Text updated) ---
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun GoalSettingContent(
   isLoading: Boolean,
   suggestedApp: AppBaselineInfo?,
   baselineAppList: List<AppBaselineInfo>,
   hourlyUsageData: Map<Int, Long>, // Already receiving the collected state
   onConfirmGoal: (selectedApp: AppBaselineInfo) -> Unit
) {
   var selectedApp by remember { mutableStateOf(suggestedApp) } // Initially select the suggested app


   // Use constant for number of apps to show
   val appsToShow = baselineAppList.take(Constants.GOAL_SETTING_APP_ICON_COUNT) // Use Constant


   // Function to calculate the display goal string (Unchanged logic, updated constants)
   fun calculateGoalString(appInfo: AppBaselineInfo?): String {
       if (appInfo == null) return "N/A"
       val baselineAverageMs = appInfo.averageDailyUsageMs
       // Use constant for reduction factor and minimum goal
       val reductionFactor = Constants.GOAL_REDUCTION_FACTOR // Use Constant
       val dailyGoalMs = (baselineAverageMs * reductionFactor).toLong().coerceAtLeast(Constants.MINIMUM_GOAL_DURATION_MS) // Use Constant
       return formatDuration(dailyGoalMs) // Use helper for formatting
   }


   Column(
       modifier = Modifier
           .fillMaxSize() // Take available space
           .padding(top = 8.dp), // Add some top padding
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       Text(stringResource(R.string.goal_setting_title), style = MaterialTheme.typography.headlineMedium) // Use stringResource
       Spacer(modifier = Modifier.height(8.dp))


       // Suggestion Text - Now incorporates suggested app name and uses stringResource
       val suggestionText = if (suggestedApp != null) {
           stringResource(R.string.goal_setting_suggestion_with_app, suggestedApp.appName) // Use stringResource
       } else {
           stringResource(R.string.goal_setting_suggestion_no_app) // Use stringResource
       }
       Text(
           text = suggestionText, // Use resolved string
           style = MaterialTheme.typography.bodyMedium,
           textAlign = TextAlign.Center
       )
       Spacer(modifier = Modifier.height(20.dp)) // More space before icons


       // --- App Icon Selection ---
       Text(stringResource(R.string.goal_setting_selection_title), style = MaterialTheme.typography.titleMedium) // Use stringResource
       Spacer(modifier = Modifier.height(12.dp))
       // Using FlowRow for simple wrapping layout of icons
       FlowRow(
           modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp),
           horizontalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterHorizontally),
           verticalArrangement = Arrangement.spacedBy(16.dp),
           maxItemsInEachRow = 4 // Adjust as needed (or make this a constant too if desired)
       ) {
           appsToShow.forEach { appInfo -> // Uses appsToShow list
               AppIconItem( // Use updated composable below
                   appInfo = appInfo,
                   isSelected = selectedApp?.packageName == appInfo.packageName,
                   onClick = { selectedApp = appInfo }
               )
           }
       }
       Spacer(modifier = Modifier.height(24.dp)) // More space after icons


       // --- Display Info for Currently Selected App ---
       // Use a Box to handle the case where nothing is selected yet
       Box(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp)) {
           if (selectedApp != null) {
               Column(horizontalAlignment = Alignment.CenterHorizontally) {
                   Text(
                       text = stringResource(R.string.goal_setting_selected_app_info, selectedApp!!.appName, formatDuration(selectedApp!!.averageDailyUsageMs)), // Use stringResource
                       style = MaterialTheme.typography.bodyLarge,
                       textAlign = TextAlign.Center
                   )
                   Spacer(modifier = Modifier.height(8.dp))
                   Text(
                       text = stringResource(R.string.goal_setting_selected_app_goal, calculateGoalString(selectedApp)), // Use stringResource
                       style = MaterialTheme.typography.bodyLarge,
                       fontWeight = FontWeight.Bold,
                       textAlign = TextAlign.Center
                   )
               }
           } else {
               Text(
                   text = stringResource(R.string.goal_setting_select_prompt), // Use stringResource
                   style = MaterialTheme.typography.bodyLarge,
                   textAlign = TextAlign.Center
               )
           }
       }


       // --- ADD: Hourly Usage Chart --- (Ensure it uses the parameter, Text updated)
       if (hourlyUsageData.isNotEmpty()) {
           Spacer(modifier = Modifier.height(24.dp))
           Text(stringResource(R.string.goal_setting_chart_title), style = MaterialTheme.typography.titleMedium) // Use stringResource
           Spacer(modifier = Modifier.height(8.dp))
           HourlyUsageBarChart( // Call updated composable below
               usageData = hourlyUsageData, // Pass the received map
               modifier = Modifier.fillMaxWidth().height(150.dp).padding(horizontal = 8.dp)
           )
       }
       // --- End Hourly Usage Chart ---




       Spacer(modifier = Modifier.weight(1f)) // Push confirm button to bottom


       // --- Confirmation Button ---
       Button(
           onClick = { selectedApp?.let { onConfirmGoal(it) } },
           enabled = selectedApp != null && !isLoading, // Enable only if an app is selected and not saving
           modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp) // Add bottom padding
       ) {
           if (isLoading) {
               CircularProgressIndicator(modifier = Modifier.size(24.dp), color = MaterialTheme.colorScheme.onPrimary)
           } else {
               // Use stringResource for button text
               val buttonText = selectedApp?.appName?.let { stringResource(R.string.goal_setting_confirm_button, it) } ?: stringResource(R.string.goal_setting_confirm_button_default)
               Text(buttonText) // Use resolved string
           }
       }
   }
}


// --- CORRECTED Composable for Bar Chart (Text updated) ---
@Composable
fun HourlyUsageBarChart(
   usageData: Map<Int, Long>, // Hour (0-23) -> Duration Ms
   modifier: Modifier = Modifier,
   barColor: Color = MaterialTheme.colorScheme.primary,
   axisLabelColor: Color = MaterialTheme.colorScheme.onSurfaceVariant, // Use a less prominent color
   axisLabelFontSize: TextUnit = 10.sp
) {
   if (usageData.isEmpty()) {
       // Optional: Show a placeholder text if no data (Use stringResource)
       Box(modifier = modifier, contentAlignment = Alignment.Center) {
           Text(stringResource(R.string.goal_setting_chart_empty), style = MaterialTheme.typography.bodySmall) // Use stringResource
       }
       return
   }


   val textMeasurer = rememberTextMeasurer()
   val density = LocalDensity.current


   // Convert SP to Px for calculations
   val axisLabelFontSizePx = remember(axisLabelFontSize) { with(density) { axisLabelFontSize.toPx() } }


   // Find max usage value to scale bars
   // Ensure maxUsageMs is at least 1 to avoid division by zero or NaN issues
   val maxUsageMs = remember(usageData) { max(1L, usageData.values.maxOrNull() ?: 1L) }




   Canvas(modifier = modifier) {
       val chartHeight = size.height
       val chartWidth = size.width
       val barCount = 24


       // Reserve space for labels at the bottom (calculate based on font size)
       // Measure a sample label ("23h") to estimate height needed
       val sampleLabelLayout = textMeasurer.measure("23h", TextStyle(fontSize = axisLabelFontSize))
       val labelHeight = sampleLabelLayout.size.height * 1.5f // Add some buffer
       val barAreaHeight = (chartHeight - labelHeight).coerceAtLeast(0f) // Ensure non-negative


       // Calculate bar width and spacing based on available width
       val totalSpacing = chartWidth * 0.1f // Example: 10% of width for spacing
       val totalBarWidth = chartWidth - totalSpacing
       val barWidth = (totalBarWidth / barCount).coerceAtLeast(1f) // Ensure at least 1px
       val barSpacing = (totalSpacing / (barCount + 1)).coerceAtLeast(0f)


       // Draw X-axis labels (e.g., 0h, 6h, 12h, 18h, 23h)
       val hoursToLabel = listOf(0, 6, 12, 18, 23)
       hoursToLabel.forEach { hour ->
           val label = "${hour}h"
           // Measure the specific label text
           val textLayoutResult: TextLayoutResult = textMeasurer.measure(
               text = label,
               style = TextStyle(color = axisLabelColor, fontSize = axisLabelFontSize)
           )
           // Calculate position: Start spacing + hour * (bar + spacing) + half bar width - half text width
           val xPos = barSpacing + hour * (barWidth + barSpacing) + (barWidth / 2f) - (textLayoutResult.size.width / 2f)
           // Ensure position is within bounds
           val clampedXPos = xPos.coerceIn(0f, chartWidth - textLayoutResult.size.width)


           // Use DrawScope.drawText
           drawText(
               textLayoutResult = textLayoutResult,
               topLeft = Offset(clampedXPos, barAreaHeight + labelHeight * 0.25f) // Position below bars, adjust offset
           )
       }


       // Draw Bars
       for (hour in 0 until barCount) {
           val usageMs = usageData.getOrDefault(hour, 0L)
           // Calculate bar height relative to max usage and available area height
           val barHeight = ((usageMs.toFloat() / maxUsageMs.toFloat()) * barAreaHeight).coerceAtLeast(0f)
           // Calculate bar start position
           val xOffset = barSpacing + hour * (barWidth + barSpacing)


           if (barHeight > 0) { // Only draw non-zero bars
               drawRect(
                   color = barColor,
                   topLeft = Offset(xOffset, barAreaHeight - barHeight), // Draw from bottom (y=barAreaHeight) up
                   size = Size(barWidth, barHeight)
               )
           }
       }
   } // End Canvas
}




// --- NEW Helper Composable for App Icon Display (Content Description updated) ---
@Composable
fun AppIconItem(
   appInfo: AppBaselineInfo,
   isSelected: Boolean,
   onClick: () -> Unit,
   iconSize: Dp = 64.dp // Make icon size configurable
) {
   Box(
       modifier = Modifier
           .size(iconSize)
           .clip(CircleShape) // Clip to circle
           .background(Color.LightGray) // Placeholder background
           .border(
               BorderStroke(
                   width = if (isSelected) 3.dp else 0.dp, // Thicker border when selected
                   color = if (isSelected) MaterialTheme.colorScheme.primary else Color.Transparent
               ),
               shape = CircleShape
           )
           .clickable(onClick = onClick),
       contentAlignment = Alignment.Center
   ) {
       Image(
           // Use Coil or Accompanist Drawable Painter
           painter = rememberAsyncImagePainter(model = appInfo.icon),
           contentDescription = stringResource(R.string.goal_setting_app_icon_description, appInfo.appName), // Use stringResource
           modifier = Modifier.padding(4.dp) // Padding inside the circle for the icon itself
               .fillMaxSize() // Let the image fill the Box
       )
   }
}


// --- NEW Helper Composable for App Item Display --- (Unchanged from original)
@Composable
fun AppInfoCard(
   appInfo: AppBaselineInfo,
   isSelected: Boolean,
   onClick: () -> Unit
) {
   Card(
       modifier = Modifier
           .fillMaxWidth()
           .clickable(onClick = onClick),
       border = if (isSelected) BorderStroke(2.dp, MaterialTheme.colorScheme.primary) else null,
       elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
   ) {
       Row(
           modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp),
           verticalAlignment = Alignment.CenterVertically
       ) {
           // TODO: Add Icon if needed: Image(painter = rememberDrawablePainter(appInfo.icon), contentDescription = null, modifier = Modifier.size(40.dp))
           Spacer(modifier = Modifier.width(16.dp)) // Placeholder if no icon
           Column(modifier = Modifier.weight(1f)) {
               Text(appInfo.appName, style = MaterialTheme.typography.bodyLarge, fontWeight = FontWeight.Bold)
               Text("Avg. Daily Use: ${formatDuration(appInfo.averageDailyUsageMs)}", style = MaterialTheme.typography.bodyMedium)
           }
           // Optional: RadioButton or Checkbox indicator for selection
       }
   }
}


// --- NEW Helper Function for Formatting Duration --- (Unchanged from original)
fun formatDuration(millis: Long): String {
   val totalMinutes = TimeUnit.MILLISECONDS.toMinutes(millis)
   val hours = totalMinutes / 60
   val minutes = totalMinutes % 60


   return when {
       hours > 0 && minutes > 0 -> "${hours}h ${minutes}m"
       hours > 0 && minutes == 0L -> "${hours}h"
       else -> "${minutes}m" // Show minutes only if less than an hour or exactly 0 hours
   }
}




// --- Flexible Deposit Setup UI Composable --- (Text updated, Constants added)
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FlexibleDepositSetupUI(onConfirm: (earn: Int, lose: Int) -> Unit) {
   // Use constants for slider defaults and ranges/steps
   var earnValue by remember { mutableFloatStateOf(Constants.DEFAULT_FLEX_EARN_SLIDER) } // Use Constant
   var loseValue by remember { mutableFloatStateOf(Constants.DEFAULT_FLEX_LOSE_SLIDER) } // Use Constant


   Column(
       modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp),
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       Text(stringResource(R.string.flex_setup_title), style = MaterialTheme.typography.headlineSmall) // Use stringResource
       Spacer(modifier = Modifier.height(16.dp))
       Text(
           stringResource(R.string.flex_setup_message), // Use stringResource
           style = MaterialTheme.typography.bodyMedium,
           textAlign = TextAlign.Center
       )
       Spacer(modifier = Modifier.height(24.dp))


       // Earn Slider
       Text(stringResource(R.string.flex_setup_earn_label, earnValue.toInt())) // Use stringResource
       Slider(
           value = earnValue,
           onValueChange = { earnValue = it },
           // Use Constants for range and steps calculation
           valueRange = Constants.FLEX_STAKES_MIN_EARN.toFloat()..Constants.FLEX_STAKES_MAX_EARN.toFloat(), // Use Constants
           steps = (Constants.FLEX_STAKES_MAX_EARN - Constants.FLEX_STAKES_MIN_EARN - 1).coerceAtLeast(0) // Use Constants, steps = range_size - 1
       )
       Spacer(modifier = Modifier.height(16.dp))


       // Lose Slider
       Text(stringResource(R.string.flex_setup_lose_label, loseValue.toInt())) // Use stringResource
       Slider(
           value = loseValue,
           onValueChange = { loseValue = it },
           // Use Constants for range and steps calculation
           valueRange = Constants.FLEX_STAKES_MIN_LOSE.toFloat()..Constants.FLEX_STAKES_MAX_LOSE.toFloat(), // Use Constants
           steps = (Constants.FLEX_STAKES_MAX_LOSE - Constants.FLEX_STAKES_MIN_LOSE - 1).coerceAtLeast(0) // Use Constants, steps = range_size - 1
       )
       Spacer(modifier = Modifier.height(24.dp))


       Button(onClick = { onConfirm(earnValue.toInt(), loseValue.toInt()) }) {
           Text(stringResource(R.string.flex_setup_confirm_button)) // Use stringResource
       }
   }
}


</MainScreen>






<Color>
package com.niyaz.zario.ui.theme


import androidx.compose.ui.graphics.Color


// Define your core palette colors here.
// You can customize these later based on your desired app appearance.
// These are standard Material 3 naming conventions.


// Example Light Theme Colors
val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)


// Example Dark Theme Colors
val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)


// You can add more specific colors if needed
val WarningYellow = Color(0xFFFFCC00)
val SuccessGreen = Color(0xFF4CAF50)
val ErrorRed = Color(0xFFB00020)

</Color>




<Theme>
package com.niyaz.zario.ui.theme


import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color // <<< Ensure this import is present
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat


// Define the Light Color Scheme using the colors from Color.kt
private val LightColorScheme = lightColorScheme(
   primary = Purple40,
   secondary = PurpleGrey40,
   tertiary = Pink40,
   background = Color(0xFFFFFBFE), // Standard light background
   surface = Color(0xFFFFFBFE), // Standard light surface
   onPrimary = Color.White, // Text/icons on Primary color background
   onSecondary = Color.White, // Text/icons on Secondary color background
   onTertiary = Color.White, // Text/icons on Tertiary color background
   onBackground = Color(0xFF1C1B1F), // Text/icons on main Background color
   onSurface = Color(0xFF1C1B1F), // Text/icons on Surface color (like Cards)
   error = ErrorRed, // Added standard error color
   onError = Color.White // Text/icons on Error color background
   /* Other default colors to override... */
)


// Define the Dark Color Scheme using the colors from Color.kt
private val DarkColorScheme = darkColorScheme(
   primary = Purple80,
   secondary = PurpleGrey80,
   tertiary = Pink80,
   background = Color(0xFF1C1B1F), // Standard dark background
   surface = Color(0xFF1C1B1F), // Standard dark surface
   onPrimary = Purple40, // Text/icons on Primary color background (CORRECTED - Use a contrast color)
   onSecondary = PurpleGrey40, // Text/icons on Secondary color background (CORRECTED - Use a contrast color)
   onTertiary = Pink40, // Text/icons on Tertiary color background (CORRECTED - Use a contrast color)
   onBackground = Color(0xFFE6E1E5), // Text/icons on main Background color
   onSurface = Color(0xFFE6E1E5), // Text/icons on Surface color
   error = ErrorRed, // Added standard error color
   onError = Color(0xFF690005) // Text/icons on Error color background (darker theme usually needs contrast)
   /* Other default colors to override... */
)


@Composable
fun ZarioTheme(
   darkTheme: Boolean = isSystemInDarkTheme(),
   dynamicColor: Boolean = false, // Keep false for consistent study colors
   content: @Composable () -> Unit
) {
   val colorScheme = when {
       dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
           val context = LocalContext.current
           if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
       }
       darkTheme -> DarkColorScheme
       else -> LightColorScheme
   }


   val view = LocalView.current
   if (!view.isInEditMode) {
       SideEffect {
           val window = (view.context as? Activity)?.window ?: return@SideEffect // Added safe cast and early return
           // Set status bar color
           window.statusBarColor = colorScheme.background.toArgb() // Use background color for status bar
           // Set status bar icons appearance (light/dark)
           WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
           // Optional: Set navigation bar color too
           // window.navigationBarColor = colorScheme.background.toArgb()
           // WindowCompat.getInsetsController(window, view).isAppearanceLightNavigationBars = !darkTheme
       }
   }


   MaterialTheme(
       colorScheme = colorScheme,
       typography = Typography,
       content = content
   )
}
</Theme>


<Type>
package com.niyaz.zario.ui.theme


import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp


// Set of Material typography styles to start with
// You can customize fonts later by adding font resources (e.g., .ttf files)
// in the `res/font` directory and defining FontFamilies.
val Typography = Typography(
   bodyLarge = TextStyle(
       fontFamily = FontFamily.Default,
       fontWeight = FontWeight.Normal,
       fontSize = 16.sp,
       lineHeight = 24.sp,
       letterSpacing = 0.5.sp
   ),
   titleLarge = TextStyle(
       fontFamily = FontFamily.Default,
       fontWeight = FontWeight.Normal,
       fontSize = 22.sp,
       lineHeight = 28.sp,
       letterSpacing = 0.sp
   ),
   labelSmall = TextStyle(
       fontFamily = FontFamily.Default,
       fontWeight = FontWeight.Medium,
       fontSize = 11.sp,
       lineHeight = 16.sp,
       letterSpacing = 0.5.sp
   )
   /* Other default text styles to override if needed:
   titleMedium=..., titleSmall=..., bodyMedium=..., bodySmall=...,
   labelMedium=..., labelLarge=...
   */
)

</Type>


<HomeViewModel>
package com.niyaz.zario.ui.viewmodels


import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.niyaz.zario.data.model.AppBaselineInfo
import com.niyaz.zario.data.repository.StudyRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.drop
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.util.Calendar
import java.util.concurrent.TimeUnit


// --- CHANGE: Constructor takes Repository, extends ViewModel ---
class HomeViewModel(private val repository: StudyRepository) : ViewModel() {


   private val TAG = "HomeViewModel" // Add TAG


   // --- State for Current Day Usage ---
   private val _todayUsageMs = MutableStateFlow<Long>(0L)
   val todayUsageMs: StateFlow<Long> = _todayUsageMs.asStateFlow()


   // State for hourly usage data
   private val _hourlyUsageData = MutableStateFlow<Map<Int, Long>>(emptyMap())
   val hourlyUsageData: StateFlow<Map<Int, Long>> = _hourlyUsageData.asStateFlow()


   // --- State for Baseline Analysis & Goal Setting ---
   // AppBaselineInfo data class moved to data.model


   // State for overall Goal Setting process
   enum class GoalSettingUiState { IDLE, LOADING, LOADED, ERROR, SAVING, SAVED }
   private val _goalSettingState = MutableStateFlow(GoalSettingUiState.IDLE)
   val goalSettingState: StateFlow<GoalSettingUiState> = _goalSettingState.asStateFlow()


   // Holds the list of apps with baseline usage for selection
   private val _baselineAppList = MutableStateFlow<List<AppBaselineInfo>>(emptyList())
   val baselineAppList: StateFlow<List<AppBaselineInfo>> = _baselineAppList.asStateFlow()


   // Holds the suggested app (most used)
   private val _suggestedApp = MutableStateFlow<AppBaselineInfo?>(null)
   val suggestedApp: StateFlow<AppBaselineInfo?> = _suggestedApp.asStateFlow()


   // --- Flow Collector Logic ---
   private val targetAppFlow = MutableStateFlow<String?>(null)
   private var usageCollectionJob: Job? = null // Keep track of the collection job


   // Store userId obtained during init
   private var currentUserId: String? = null




   init {
       Log.d(TAG, "ViewModel Initializing")
       viewModelScope.launch { // Use viewModelScope directly
           // Fetch and store userId first
           currentUserId = repository.getUserId() // Get userId from repository
           if (currentUserId == null) {
               Log.e(TAG, "ViewModel initialized but User ID is null. Usage data will not be collected.")
               // Optionally handle this state, e.g., trigger logout or show error
               return@launch // Stop further initialization if no userId
           }
           Log.d(TAG, "ViewModel initialized for user: $currentUserId")


           // Load initial target app
           targetAppFlow.value = repository.getTargetApp() // Use repository
           Log.d(TAG, "Initial target app loaded: ${targetAppFlow.value}")


           // Start collecting usage immediately
           startOrUpdateUsageCollection()
       }


       // Observe changes in the target app and restart collection if needed
       viewModelScope.launch {
           targetAppFlow
               .drop(1) // Skip initial value emission as it's handled above
               .distinctUntilChanged()
               .collect { currentTargetApp ->
                   Log.d(TAG, "Target app changed to: $currentTargetApp. Restarting usage collection.")
                   startOrUpdateUsageCollection() // Restart collection when target changes
               }
       }


   } // End Init


   private fun startOrUpdateUsageCollection() {
       usageCollectionJob?.cancel() // Cancel previous collection job if running
       val currentTargetApp = targetAppFlow.value
       val userId = currentUserId // Use the stored userId


       // Ensure both userId and targetApp are available
       if (userId != null && currentTargetApp != null) {
           usageCollectionJob = viewModelScope.launch { // Launch new collection in viewModelScope
               val todayStartMs = getStartOfDayTimestamp(System.currentTimeMillis())
               Log.d(TAG, "Collecting today's usage flow for user $userId, app: $currentTargetApp, DayStart: $todayStartMs")


               // Combine repository flow with a ticker to ensure updates even if DB doesn't change frequently
               combine(
                   // Pass userId to the repository method
                   repository.getTodayUsageForAppFlow(userId, currentTargetApp, todayStartMs),
                   tickerFlow(TimeUnit.MINUTES.toMillis(5)) // Check every 5 mins
               ) { usage, _ -> usage } // Combine logic: take the usage value
                   .catch { e -> Log.e(TAG, "Error collecting today's usage flow for user $userId", e) }
                   .distinctUntilChanged() // Only emit if the usage value changes
                   .collect { usage ->
                       val currentUsage = usage ?: 0L
                       if (_todayUsageMs.value != currentUsage) {
                           _todayUsageMs.value = currentUsage
                           // Log only on change to reduce noise
                           Log.d(TAG, "Updated todayUsageMs for user $userId: ${_todayUsageMs.value}")
                       }
                   }
           }
       } else {
           // If target app becomes null or userId is missing, reset usage to 0
           _todayUsageMs.value = 0L
           Log.d(TAG, "Target app ($currentTargetApp) or User ID ($userId) is null. Usage set to 0. Usage collection stopped.")
       }
   }




   // --- Baseline Analysis Logic ---


   /**
    * Triggers the calculation and loading of baseline data when entering GOAL_SETTING phase.
    */
   fun loadBaselineData() {
       if (_goalSettingState.value != GoalSettingUiState.IDLE && _goalSettingState.value != GoalSettingUiState.ERROR) {
           Log.d(TAG, "Baseline data already loading or loaded. State: ${_goalSettingState.value}")
           return
       }
       Log.d(TAG, "Starting baseline data load...")
       _goalSettingState.value = GoalSettingUiState.LOADING
       val userId = currentUserId // Get stored userId


       if (userId == null) {
           Log.e(TAG, "Cannot load baseline data: User ID is null.")
           _goalSettingState.value = GoalSettingUiState.ERROR // Set error state
           return
       }


       viewModelScope.launch(Dispatchers.IO) { // Use IO dispatcher for repository calls
           try {
               // --- Use Repository ---
               val baselineStartTime = repository.getStudyStartTimestamp()
               if (baselineStartTime <= 0) {
                   Log.e(TAG, "Invalid baseline start time ($baselineStartTime). Cannot load data.")
                   withContext(Dispatchers.Main) { _goalSettingState.value = GoalSettingUiState.ERROR }
                   return@launch
               }


               val baselineDurationDays = 7
               val baselineEndTime = baselineStartTime + TimeUnit.DAYS.toMillis(baselineDurationDays.toLong())
               val now = System.currentTimeMillis()


               if (now < baselineEndTime) {
                   Log.w(TAG, "Attempted to load baseline data before baseline period ended.")
                   withContext(Dispatchers.Main) { _goalSettingState.value = GoalSettingUiState.IDLE }
                   return@launch
               }


               Log.d(TAG, "Fetching baseline usage for user $userId between $baselineStartTime and $baselineEndTime")
               // --- Use Repository, passing userId ---
               val aggregatedUsage = repository.getAggregatedUsageForBaseline(userId, baselineStartTime, baselineEndTime)
               val hourlyRecords = repository.getAllUsageRecordsForBaseline(userId, baselineStartTime, baselineEndTime)


               // --- Process Hourly Usage (Unchanged logic, just source is different) ---
               val hourlyMap = mutableMapOf<Int, Long>()
               hourlyRecords.forEach { record ->
                   val instant = Instant.ofEpochMilli(record.intervalStartTimestamp)
                   val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
                   val hour = dateTime.hour
                   hourlyMap[hour] = hourlyMap.getOrDefault(hour, 0L) + record.durationMs
               }
               withContext(Dispatchers.Main) { _hourlyUsageData.value = hourlyMap.toMap() } // Update on Main thread
               Log.d(TAG, "Processed hourly usage data for user $userId: ${_hourlyUsageData.value.size} hours with data.")


               if (aggregatedUsage.isEmpty()) {
                   Log.w(TAG, "No significant baseline usage data found for user $userId.")
                   withContext(Dispatchers.Main) {
                       _baselineAppList.value = emptyList()
                       _suggestedApp.value = null
                       _hourlyUsageData.value = emptyMap()
                       _goalSettingState.value = GoalSettingUiState.LOADED // Loaded, but empty
                   }
                   return@launch
               }


               // Calculate average daily usage and map to AppBaselineInfo
               val appInfoList = aggregatedUsage.map { baseline ->
                   val averageDailyMs = baseline.totalDurationMs / baselineDurationDays
                   // --- Use Repository to get details (name/icon) ---
                   // Repository call getAppDetails does not need userId
                   val appDetails = repository.getAppDetails(baseline.packageName)
                   AppBaselineInfo(
                       packageName = baseline.packageName,
                       appName = appDetails.appName,
                       averageDailyUsageMs = averageDailyMs, // Now add the calculated average
                       icon = appDetails.icon
                   )
               }


               withContext(Dispatchers.Main) { // Update StateFlows on Main thread
                   _baselineAppList.value = appInfoList
                   _suggestedApp.value = appInfoList.firstOrNull()
                   Log.d(TAG, "Baseline data loaded for user $userId. Suggesting: ${_suggestedApp.value?.appName}. Total apps found: ${appInfoList.size}")
                   _goalSettingState.value = GoalSettingUiState.LOADED
               }


           } catch (e: Exception) {
               Log.e(TAG, "Error loading baseline data for user $userId", e)
               withContext(Dispatchers.Main) {
                   _goalSettingState.value = GoalSettingUiState.ERROR
                   _baselineAppList.value = emptyList()
                   _suggestedApp.value = null
                   _hourlyUsageData.value = emptyMap()
               }
           }
       }
   } // End loadBaselineData




   // --- Goal Setting Confirmation Logic ---


   /**
    * Called when the user confirms their target app selection.
    * Uses the repository to calculate the goal, persist the data, and transition the phase.
    *
    * @param selectedAppInfo The AppBaselineInfo object for the app chosen by the user.
    */
   fun confirmGoalSelection(selectedAppInfo: AppBaselineInfo?) {
       if (selectedAppInfo == null) {
           Log.e(TAG, "Confirm button clicked but selectedAppInfo is null.")
           // Optionally update state to show an error message in UI
           return
       }
       if (_goalSettingState.value != GoalSettingUiState.LOADED) {
           Log.w(TAG, "Confirm button clicked in unexpected state: ${_goalSettingState.value}")
           return
       }


       val userId = currentUserId // Use stored userId for logging/potential use
       Log.d(TAG, "Confirming goal selection for user $userId: ${selectedAppInfo.appName}")
       _goalSettingState.value = GoalSettingUiState.SAVING


       viewModelScope.launch(Dispatchers.IO) { // Use IO for repository operation
           try {
               // Calculate 20% reduction goal (FR015)
               val baselineAverageMs = selectedAppInfo.averageDailyUsageMs
               val reductionFactor = 0.80
               val dailyGoalMs = (baselineAverageMs * reductionFactor).toLong().coerceAtLeast(60000L)
               Log.d(TAG, "Baseline Avg: $baselineAverageMs ms, Calculated Goal: $dailyGoalMs ms")


               // --- Use Repository's combined operation ---
               // Check again just before critical operation
               val confirmedUserId = currentUserId
               if (confirmedUserId == null) {
                   throw IllegalStateException("User ID not found for goal confirmation.")
               }
               val result = repository.confirmGoalSelection(
                   userId = confirmedUserId, // Pass confirmed userId
                   selectedAppPkg = selectedAppInfo.packageName,
                   calculatedGoalMs = dailyGoalMs
               )


               if (result.isSuccess) {
                   // Refresh the target app flow for today's usage tracking
                   // This will trigger startOrUpdateUsageCollection via the flow collector
                   targetAppFlow.value = selectedAppInfo.packageName


                   Log.i(TAG, "Goal confirmed and saved via repository for user $confirmedUserId. Target: ${selectedAppInfo.packageName}, Goal: $dailyGoalMs ms.")
                   withContext(Dispatchers.Main) {
                       _goalSettingState.value = GoalSettingUiState.SAVED
                   }
               } else {
                   throw result.exceptionOrNull() ?: Exception("Unknown error saving goal selection.")
               }


           } catch (e: Exception) {
               Log.e(TAG, "Error saving goal selection for user $userId", e)
               withContext(Dispatchers.Main) {
                   _goalSettingState.value = GoalSettingUiState.ERROR
                   // Consider adding a specific error message StateFlow for the UI
               }
           }
       }
   } // End confirmGoalSelection




   // --- Helper Functions ---
   private fun getStartOfDayTimestamp(timestamp: Long): Long {
       return Calendar.getInstance().apply {
           timeInMillis = timestamp
           set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0)
       }.timeInMillis
   }


   private fun tickerFlow(period: Long, initialDelay: Long = 0L) = flow {
       delay(initialDelay)
       while(true) {
           emit(Unit)
           delay(period)
       }
   }


   /** Refreshes the target app state from the repository. */
   fun refreshTargetApp() {
       // No userId needed here as it just reads local state via repo/stateManager
       viewModelScope.launch { // No specific dispatcher needed for reading from repo here
           val currentTarget = targetAppFlow.value
           val refreshedTarget = repository.getTargetApp()
           // Update the flow only if the value has actually changed
           if (currentTarget != refreshedTarget) {
               targetAppFlow.value = refreshedTarget
               Log.d(TAG, "Target app manually refreshed: ${targetAppFlow.value}")
           } else {
               Log.d(TAG, "Target app refresh requested but value hasn't changed: $refreshedTarget")
           }
       }
   }


   // --- Add Factory for ViewModel Instantiation ---
   companion object {
       fun provideFactory(
           repository: StudyRepository
       ): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
           @Suppress("UNCHECKED_CAST")
           override fun <T : ViewModel> create(modelClass: Class<T>): T {
               if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {
                   return HomeViewModel(repository) as T
               }
               throw IllegalArgumentException("Unknown ViewModel class")
           }
       }
   }
}


</HomeViewModel>




<AppInfoHelper>
package com.niyaz.zario.utils


import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.graphics.drawable.Drawable
import android.util.Log
import androidx.core.content.res.ResourcesCompat // For loading default icon


object AppInfoHelper {


   private const val TAG = "AppInfoHelper"
   // Cache now includes Drawable?
   private val appInfoCache = mutableMapOf<String, AppDetails>()


   data class AppDetails(
       val appName: String,
       val icon: Drawable? // Store the actual icon
   )


   // Keep getAppName for simplicity if only name is needed elsewhere
   fun getAppName(context: Context, packageName: String): String {
       return getAppDetails(context, packageName).appName
   }


   /**
    * Gets the AppDetails (name, icon) for a given package name.
    * Caches results for efficiency.
    * Includes a fallback default icon.
    *
    * @param context Context to access PackageManager.
    * @param packageName The package name of the application.
    * @return AppDetails containing the name and icon.
    */
   fun getAppDetails(context: Context, packageName: String): AppDetails {
       appInfoCache[packageName]?.let { return it }


       val pm = context.packageManager
       val defaultIcon = ResourcesCompat.getDrawable(context.resources, android.R.mipmap.sym_def_app_icon, null) // Standard default icon


       return try {
           val appInfo: ApplicationInfo? = try {
               pm.getApplicationInfo(packageName, 0)
           } catch (e: PackageManager.NameNotFoundException) {
               null
           }


           val appName = appInfo?.let { pm.getApplicationLabel(it).toString() } ?: packageName
           val icon = appInfo?.loadIcon(pm) ?: defaultIcon // Use loaded icon or default


           val details = AppDetails(appName = appName, icon = icon)
           appInfoCache[packageName] = details
           details
       } catch (e: Exception) {
           Log.e(TAG, "Failed to get app details for $packageName: ${e.message}", e)
           // Fallback with package name and default icon
           AppDetails(appName = packageName, icon = defaultIcon)
       }
   }


   fun clearCache() {
       appInfoCache.clear()
   }
}


</AppInfoHelper>






<Constants>
package com.niyaz.zario.utils


import java.util.concurrent.TimeUnit


/**
* Central object for holding application-wide constants.
*/
object Constants {


   // --- SharedPreferences Keys (from StudyStateManager) ---
   const val PREFS_NAME = "ZarioStudyStatePrefs"
   const val KEY_STUDY_PHASE = "study_phase"
   const val KEY_STUDY_START_TIMESTAMP = "study_start_timestamp"
   const val KEY_CONDITION = "study_condition"
   const val KEY_TARGET_APP = "target_app_package"
   const val KEY_DAILY_GOAL_MS = "daily_goal_ms"
   const val KEY_POINTS_BALANCE = "points_balance"
   const val KEY_FLEX_POINTS_EARN = "flex_points_earn"
   const val KEY_FLEX_POINTS_LOSE = "flex_points_lose"
   const val KEY_USER_ID = "user_id"
   const val KEY_LAST_DAILY_CHECK_TIMESTAMP = "last_daily_check_timestamp"
   const val KEY_LAST_DAY_GOAL_REACHED = "last_day_goal_reached"
   const val KEY_LAST_DAY_POINTS_CHANGE = "last_day_points_change"


   // --- Firestore ---
   const val FIRESTORE_COLLECTION_USERS = "users"
   const val FIRESTORE_FIELD_EMAIL = "email"
   const val FIRESTORE_FIELD_YOB = "yearOfBirth"
   const val FIRESTORE_FIELD_GENDER = "gender"
   const val FIRESTORE_FIELD_REG_TIMESTAMP = "registrationTimestamp"
   const val FIRESTORE_FIELD_STUDY_PHASE = "studyPhase"
   const val FIRESTORE_FIELD_STUDY_CONDITION = "studyCondition"
   const val FIRESTORE_FIELD_STUDY_START_TIMESTAMP = "studyStartTimestamp"
   const val FIRESTORE_FIELD_POINTS_BALANCE = "pointsBalance"
   const val FIRESTORE_FIELD_TARGET_APP = "targetAppPackage"
   const val FIRESTORE_FIELD_DAILY_GOAL = "dailyGoalMs"
   const val FIRESTORE_FIELD_FLEX_EARN = "flexPointsEarn"
   const val FIRESTORE_FIELD_FLEX_LOSE = "flexPointsLose"


   // --- Usage Tracking Service ---
   const val USAGE_TRACKING_CHANNEL_ID = "com.niyaz.zario.TRACKING_CHANNEL"
   const val USAGE_TRACKING_FOREGROUND_NOTIF_ID = 1
   const val USAGE_TRACKING_DAILY_FEEDBACK_NOTIF_ID = 2
   const val USAGE_TRACKING_WARN_90_NOTIF_ID = 3
   const val USAGE_TRACKING_LIMIT_100_NOTIF_ID = 4
   val USAGE_TRACKING_INTERVAL_MS: Long = TimeUnit.MINUTES.toMillis(1) // Check every 1 minute
   // val USAGE_TRACKING_INTERVAL_MS: Long = TimeUnit.SECONDS.toMillis(15) // TESTING VALUE
   const val USAGE_TRACKING_MIN_SAVE_DURATION_MS = 1000L // Min duration to save to DB


   // --- Daily Check Worker ---
   const val DAILY_CHECK_WORKER_NAME = "ZarioDailyCheck"
   const val DEFAULT_CHECK_WORKER_INTERVAL_HOURS = 1L


   // --- Study Logic ---
   const val BASELINE_DURATION_DAYS = 7
   const val GOAL_REDUCTION_FACTOR = 0.80 // 20% reduction
   const val MINIMUM_GOAL_DURATION_MS = 60000L // 1 minute
   const val INITIAL_POINTS = 100
   const val MAX_POINTS = 1200
   const val MIN_POINTS = 0
   const val DEFAULT_CONTROL_EARN_POINTS = 10
   const val DEFAULT_CONTROL_LOSE_POINTS = 0 // No change on failure
   const val DEFAULT_DEPOSIT_EARN_POINTS = 10
   const val DEFAULT_DEPOSIT_LOSE_POINTS = 40 // Positive value representing loss
   const val FLEX_STAKES_MIN_EARN = 0
   const val FLEX_STAKES_MAX_EARN = 10
   const val FLEX_STAKES_MIN_LOSE = 0
   const val FLEX_STAKES_MAX_LOSE = 40
   const val DEFAULT_FLEX_EARN_SLIDER = 5f
   const val DEFAULT_FLEX_LOSE_SLIDER = 20f


   // --- Authentication ---
   const val MIN_PASSWORD_LENGTH = 8
   const val MIN_BIRTH_YEAR = 1900


   // --- Goal Setting UI ---
   const val GOAL_SETTING_APP_ICON_COUNT = 4 // Number of app icons to show


}
</Constants>






<PermissionsUtils>
package com.niyaz.zario.utils


import android.app.AppOpsManager
import android.content.Context
import android.content.Intent
import android.os.Build
import android.provider.Settings
import androidx.core.content.ContextCompat


object PermissionsUtils {


   /**
    * Checks if the Usage Stats permission (PACKAGE_USAGE_STATS) is granted.
    *
    * @param context The application context.
    * @return True if permission is granted, false otherwise.
    */
   fun hasUsageStatsPermission(context: Context): Boolean {
       val appOpsManager = ContextCompat.getSystemService(context, AppOpsManager::class.java) ?: return false
       // Mode flags have changed meanings slightly over APIs. AppOpsManager.OPSTR_GET_USAGE_STATS is the key string.
       val mode = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
           appOpsManager.unsafeCheckOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, android.os.Process.myUid(), context.packageName)
       } else {
           @Suppress("DEPRECATION") // Use the deprecated checkOpNoThrow for older APIs
           appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, android.os.Process.myUid(), context.packageName)
       }
       return mode == AppOpsManager.MODE_ALLOWED
   }


   /**
    * Creates an Intent to navigate the user to the system settings screen
    * where they can grant the Usage Stats permission.
    *
    * @return An Intent to start the settings activity.
    */
   fun getUsageStatsPermissionIntent(): Intent {
       return Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)
       // Optional: Add flags if needed, e.g., Intent.FLAG_ACTIVITY_NEW_TASK
   }
}


</PermissionsUtils>


<StudyPhase>
package com.niyaz.zario // Or com.niyaz.zario.model


enum class StudyPhase {
   /** User has registered but study hasn't formally started (e.g., waiting for conditions). */
   REGISTERED,
   /** Initial 7-day period for tracking baseline usage. */
   BASELINE,
   /** Phase where user confirms target app and goal after baseline. */
   GOAL_SETTING,
   /** Intervention active - Control group. */
   INTERVENTION_CONTROL,
   /** Intervention active - Deposit group. */
   INTERVENTION_DEPOSIT,
   /** Intervention active - Flexible Deposit group. */
   INTERVENTION_FLEXIBLE,
   /** Study completed or user withdrawn. */
   COMPLETED
}
</StudyPhase>






<StudyStateManager>
package com.niyaz.zario.utils


import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.StudyPhase
import kotlinx.coroutines.tasks.await


object StudyStateManager {


   // Use constants for keys
   private const val PREFS_NAME = Constants.PREFS_NAME // Keep local if only used here, or reference Constants
   private const val KEY_STUDY_PHASE = Constants.KEY_STUDY_PHASE
   private const val KEY_STUDY_START_TIMESTAMP = Constants.KEY_STUDY_START_TIMESTAMP
   private const val KEY_CONDITION = Constants.KEY_CONDITION
   private const val KEY_TARGET_APP = Constants.KEY_TARGET_APP
   private const val KEY_DAILY_GOAL_MS = Constants.KEY_DAILY_GOAL_MS
   private const val KEY_POINTS_BALANCE = Constants.KEY_POINTS_BALANCE
   private const val KEY_FLEX_POINTS_EARN = Constants.KEY_FLEX_POINTS_EARN
   private const val KEY_FLEX_POINTS_LOSE = Constants.KEY_FLEX_POINTS_LOSE
   private const val KEY_USER_ID = Constants.KEY_USER_ID
   private const val KEY_LAST_DAILY_CHECK_TIMESTAMP = Constants.KEY_LAST_DAILY_CHECK_TIMESTAMP
   private const val KEY_LAST_DAY_GOAL_REACHED = Constants.KEY_LAST_DAY_GOAL_REACHED
   private const val KEY_LAST_DAY_POINTS_CHANGE = Constants.KEY_LAST_DAY_POINTS_CHANGE


   private const val TAG = "StudyStateManager" // Add TAG


   private fun getPreferences(context: Context): SharedPreferences {
       // Use constant for prefs name
       return context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
   }


   // --- Methods using Keys ---
   // (No logic change, just ensure keys used above are from Constants)


   fun saveUserId(context: Context, userId: String) {
       getPreferences(context).edit().putString(KEY_USER_ID, userId).apply()
   }
   fun getUserId(context: Context): String? {
       return getPreferences(context).getString(KEY_USER_ID, null)
   }


   fun saveStudyPhase(context: Context, phase: StudyPhase) {
       getPreferences(context).edit().putString(KEY_STUDY_PHASE, phase.name).apply()
       Log.d(TAG, "Saved Study Phase: ${phase.name}")
   }


   fun getStudyPhase(context: Context): StudyPhase {
       val phaseName = getPreferences(context).getString(KEY_STUDY_PHASE, StudyPhase.REGISTERED.name)
       return try {
           StudyPhase.valueOf(phaseName ?: StudyPhase.REGISTERED.name)
       } catch (e: IllegalArgumentException) {
           Log.e(TAG, "Invalid phase name '$phaseName' found in prefs, defaulting to REGISTERED.")
           StudyPhase.REGISTERED
       }
   }


   fun saveStudyStartTimestamp(context: Context, timestamp: Long) {
       getPreferences(context).edit().putLong(KEY_STUDY_START_TIMESTAMP, timestamp).apply()
       Log.d(TAG, "Saved Study Start Timestamp: $timestamp")
   }


   fun getStudyStartTimestamp(context: Context): Long {
       return getPreferences(context).getLong(KEY_STUDY_START_TIMESTAMP, 0L)
   }


   fun saveTargetApp(context: Context, packageName: String?) {
       getPreferences(context).edit().putString(KEY_TARGET_APP, packageName).apply()
       Log.d(TAG, "Saved Target App: $packageName")
   }
   fun getTargetApp(context: Context): String? {
       return getPreferences(context).getString(KEY_TARGET_APP, null)
   }


   fun saveDailyGoalMs(context: Context, goalMs: Long?) {
       val editor = getPreferences(context).edit()
       if (goalMs != null) {
           editor.putLong(KEY_DAILY_GOAL_MS, goalMs)
       } else {
           editor.remove(KEY_DAILY_GOAL_MS)
       }
       editor.apply()
       Log.d(TAG, "Saved Daily Goal (ms): $goalMs")
   }
   fun getDailyGoalMs(context: Context): Long? {
       val goal = getPreferences(context).getLong(KEY_DAILY_GOAL_MS, -1L)
       return if (goal == -1L) null else goal
   }


   fun saveCondition(context: Context, condition: StudyPhase) {
       if(condition in listOf(StudyPhase.INTERVENTION_CONTROL, StudyPhase.INTERVENTION_DEPOSIT, StudyPhase.INTERVENTION_FLEXIBLE)){
           getPreferences(context).edit().putString(KEY_CONDITION, condition.name).apply()
       } else {
           Log.w(TAG, "Attempted to save invalid condition: $condition")
       }
   }
   fun getCondition(context: Context): StudyPhase? {
       val conditionName = getPreferences(context).getString(KEY_CONDITION, null)
       return try {
           conditionName?.let { StudyPhase.valueOf(it) }
       } catch (e: IllegalArgumentException) { null }
   }


   fun savePointsBalance(context: Context, points: Int) {
       getPreferences(context).edit().putInt(KEY_POINTS_BALANCE, points).apply()
   }
   fun getPointsBalance(context: Context): Int {
       // Use constant for default value
       return getPreferences(context).getInt(KEY_POINTS_BALANCE, Constants.INITIAL_POINTS)
   }


   fun saveFlexStakes(context: Context, earn: Int, lose: Int) {
       getPreferences(context).edit()
           .putInt(KEY_FLEX_POINTS_EARN, earn)
           .putInt(KEY_FLEX_POINTS_LOSE, lose)
           .apply()
   }
   fun getFlexStakes(context: Context): Pair<Int?, Int?> {
       val prefs = getPreferences(context)
       // Use Constants for defaults/range check if needed, though currently returning null if not present
       val earn = if (prefs.contains(KEY_FLEX_POINTS_EARN)) prefs.getInt(KEY_FLEX_POINTS_EARN, Constants.FLEX_STAKES_MIN_EARN) else null
       val lose = if (prefs.contains(KEY_FLEX_POINTS_LOSE)) prefs.getInt(KEY_FLEX_POINTS_LOSE, Constants.FLEX_STAKES_MIN_LOSE) else null
       return Pair(earn, lose)
   }


   fun saveDailyOutcome(context: Context, checkTimestamp: Long, goalReached: Boolean, pointsChange: Int) {
       getPreferences(context).edit()
           .putLong(KEY_LAST_DAILY_CHECK_TIMESTAMP, checkTimestamp)
           .putBoolean(KEY_LAST_DAY_GOAL_REACHED, goalReached)
           .putInt(KEY_LAST_DAY_POINTS_CHANGE, pointsChange)
           .apply()
       Log.d(TAG, "Saved Daily Outcome: Time=$checkTimestamp, Reached=$goalReached, Change=$pointsChange")
   }


   fun getLastDailyOutcome(context: Context): Triple<Long?, Boolean?, Int?> {
       val prefs = getPreferences(context)
       val timestamp = if(prefs.contains(KEY_LAST_DAILY_CHECK_TIMESTAMP)) prefs.getLong(KEY_LAST_DAILY_CHECK_TIMESTAMP, 0L) else null
       val reached = if(prefs.contains(KEY_LAST_DAY_GOAL_REACHED)) prefs.getBoolean(KEY_LAST_DAY_GOAL_REACHED, false) else null
       val change = if(prefs.contains(KEY_LAST_DAY_POINTS_CHANGE)) prefs.getInt(KEY_LAST_DAY_POINTS_CHANGE, 0) else null
       return Triple(timestamp, reached, change)
   }


   suspend fun fetchAndSaveStateFromFirestore(context: Context, userId: String): Boolean {
       Log.d(TAG, "Attempting to fetch state for user: $userId")
       val firestore: FirebaseFirestore = Firebase.firestore
       // Use constant for collection name
       val userDocRef = firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)


       return try {
           val document = userDocRef.get().await()
           if (document != null && document.exists()) {
               Log.d(TAG, "Firestore document found. Data: ${document.data}")
               val editor = getPreferences(context).edit()


               editor.putString(KEY_USER_ID, userId)


               // Use Constants for Firestore fields
               val phaseName = document.getString(Constants.FIRESTORE_FIELD_STUDY_PHASE)
               try {
                   val phase = phaseName?.let { StudyPhase.valueOf(it) } ?: StudyPhase.REGISTERED
                   editor.putString(KEY_STUDY_PHASE, phase.name)
               } catch (e: IllegalArgumentException) {
                   Log.e(TAG, "Invalid phase '$phaseName' in Firestore, defaulting.")
                   editor.putString(KEY_STUDY_PHASE, StudyPhase.REGISTERED.name)
               }


               document.getLong(Constants.FIRESTORE_FIELD_STUDY_START_TIMESTAMP)?.let { editor.putLong(KEY_STUDY_START_TIMESTAMP, it) }
               document.getString(Constants.FIRESTORE_FIELD_STUDY_CONDITION)?.let { editor.putString(KEY_CONDITION, it) }
               document.getLong(Constants.FIRESTORE_FIELD_POINTS_BALANCE)?.let { editor.putInt(KEY_POINTS_BALANCE, it.toInt()) }
               document.getString(Constants.FIRESTORE_FIELD_TARGET_APP)?.let { editor.putString(KEY_TARGET_APP, it) }
               document.getLong(Constants.FIRESTORE_FIELD_DAILY_GOAL)?.let { editor.putLong(KEY_DAILY_GOAL_MS, it) }
               document.getLong(Constants.FIRESTORE_FIELD_FLEX_EARN)?.let { editor.putInt(KEY_FLEX_POINTS_EARN, it.toInt()) }
               document.getLong(Constants.FIRESTORE_FIELD_FLEX_LOSE)?.let { editor.putInt(KEY_FLEX_POINTS_LOSE, it.toInt()) }


               editor.apply()
               Log.i(TAG, "Successfully fetched and saved state from Firestore.")
               true
           } else {
               Log.w(TAG, "Firestore document not found for user: $userId")
               clearStudyState(context)
               false
           }
       } catch (e: Exception) {
           Log.e(TAG, "Error fetching state from Firestore", e)
           false
       }
   }


   fun clearStudyState(context: Context) {
       getPreferences(context).edit().clear().apply()
       Log.d(TAG, "Cleared Study State.")
   }
}


</StudyStateManager>




<DailyCheckWorker>
package com.niyaz.zario.workers


import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.StudyPhase
import com.niyaz.zario.data.local.AppDatabase
import com.niyaz.zario.utils.Constants
import com.niyaz.zario.utils.StudyStateManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.util.Calendar


// Apply changes from <change> to the starter <code>
class DailyCheckWorker(appContext: Context, workerParams: WorkerParameters) :
   CoroutineWorker(appContext, workerParams) {


   companion object {
       const val TAG = "DailyCheckWorker"
       // Use constant for worker name
       const val UNIQUE_WORK_NAME = Constants.DAILY_CHECK_WORKER_NAME
   }


   override suspend fun doWork(): Result {
       Log.d(TAG, "Worker starting...")
       val currentTime = System.currentTimeMillis() // Timestamp for this check run




       return withContext(Dispatchers.IO) {
           try {
               val userId = StudyStateManager.getUserId(applicationContext)
               if (userId == null) {
                   Log.e(TAG, "User ID not found. Cannot perform daily check.")
                   return@withContext Result.failure()
               }


               val phase = StudyStateManager.getStudyPhase(applicationContext)
               if (!phase.name.startsWith("INTERVENTION")) {
                   Log.i(TAG, "Not in an intervention phase ($phase). Skipping.")
                   return@withContext Result.success()
               }


               Log.i(TAG, "Running daily check for user $userId in phase $phase")


               // Get state needed for calculation
               val condition = StudyStateManager.getCondition(applicationContext) ?: phase
               val targetApp = StudyStateManager.getTargetApp(applicationContext)
               val dailyGoalMs = StudyStateManager.getDailyGoalMs(applicationContext)
               val currentPoints = StudyStateManager.getPointsBalance(applicationContext)
               // Fetch flexible stakes regardless, will only be used if needed
               val (flexEarn, flexLose) = StudyStateManager.getFlexStakes(applicationContext)


               // --- Validation of required state ---
               if (targetApp == null) {
                   Log.e(TAG, "Target app not set for user $userId. Cannot check goal.")
                   return@withContext Result.failure()
               }
               if (dailyGoalMs == null) {
                   Log.e(TAG, "Daily goal not set for user $userId. Cannot check goal.")
                   return@withContext Result.failure()
               }
               // Use constants for flex stake validation and range check
               if (condition == StudyPhase.INTERVENTION_FLEXIBLE && (flexEarn == null || flexLose == null || flexEarn !in Constants.FLEX_STAKES_MIN_EARN..Constants.FLEX_STAKES_MAX_EARN || flexLose !in Constants.FLEX_STAKES_MIN_LOSE..Constants.FLEX_STAKES_MAX_LOSE)) {
                   Log.e(TAG, "Flexible stakes invalid ($flexEarn, $flexLose) for user $userId. Cannot calculate points.")
                   return@withContext Result.failure()
               }
               // --- End Validation ---


               // 1. Calculate Timestamps for Previous Day
               val (prevDayStart, _) = getPreviousDayTimestamps() // Only need start for daily DAO query


               // 2. Query Database for Previous Day's Usage
               val dao = AppDatabase.getDatabase(applicationContext).usageStatDao()
               // --- Corrected DAO Call: Pass userId, packageName, dayTimestamp ---
               val totalUsageMs = dao.getTotalDurationForAppOnDay(
                   userId = userId, // Pass the userId obtained earlier
                   packageName = targetApp, // Correct position
                   dayTimestamp = prevDayStart // Correct position
               ) ?: 0L
               // --- End Corrected DAO Call ---
               Log.i(TAG, "Previous day ($prevDayStart) total usage for $targetApp: ${totalUsageMs / 1000.0} seconds")


               // 3. Compare Usage to Goal
               val goalReached = totalUsageMs <= dailyGoalMs // Removed !! assertion as validation ensures not null
               Log.i(TAG, "Daily goal ($dailyGoalMs ms): ${if(goalReached) "REACHED" else "MISSED"}")


               // 4. Determine Points Change based on Condition
               // Pass fetched stakes to the calculation function
               val pointsChange = calculatePointsChange(condition, goalReached, flexEarn, flexLose)


               // *** ALIGNMENT CHANGE: Coerce points between MIN_POINTS and MAX_POINTS using Constants ***
               val newPoints = (currentPoints + pointsChange).coerceIn(Constants.MIN_POINTS, Constants.MAX_POINTS) // Use constants for point bounds
               Log.i(TAG, "Condition: $condition, Goal Reached: $goalReached -> Points change: $pointsChange, New Balance: $newPoints (Coerced)")


               // --- ADDED: Save Daily Outcome ---
               StudyStateManager.saveDailyOutcome(applicationContext, currentTime, goalReached, pointsChange)
               // --- End Save Daily Outcome ---


               // 5. Update Points (Local & Firestore) if changed
               if (newPoints != currentPoints) {
                   StudyStateManager.savePointsBalance(applicationContext, newPoints)
                   updatePointsInFirestore(userId, newPoints) // Removed !! assertion as validation ensures not null
               } else {
                   Log.d(TAG,"Points balance unchanged.")
               }


               Log.d(TAG, "Worker finished successfully.")
               Result.success()


           } catch (e: Exception) {
               Log.e(TAG, "Worker failed", e)
               Result.retry()
           }
       } // End withContext
   }




   // Unchanged as per <change> which used /* ... */
   private fun getPreviousDayTimestamps(): Pair<Long, Long> {
       val calendar = Calendar.getInstance()
       // Move to yesterday
       calendar.add(Calendar.DAY_OF_YEAR, -1)
       // Set to start of yesterday
       calendar.set(Calendar.HOUR_OF_DAY, 0)
       calendar.set(Calendar.MINUTE, 0)
       calendar.set(Calendar.SECOND, 0)
       calendar.set(Calendar.MILLISECOND, 0)
       val startTimestamp = calendar.timeInMillis
       // Set to end of yesterday
       calendar.set(Calendar.HOUR_OF_DAY, 23)
       calendar.set(Calendar.MINUTE, 59)
       calendar.set(Calendar.SECOND, 59)
       calendar.set(Calendar.MILLISECOND, 999)
       val endTimestamp = calendar.timeInMillis
       return Pair(startTimestamp, endTimestamp)
   }


   private fun calculatePointsChange(
       condition: StudyPhase,
       goalReached: Boolean,
       flexEarn: Int?, // Pass fetched value
       flexLose: Int?  // Pass fetched value
   ): Int {
       // Use Constants for default earn/lose values
       val controlEarn = Constants.DEFAULT_CONTROL_EARN_POINTS
       val depositEarn = Constants.DEFAULT_DEPOSIT_EARN_POINTS
       val depositLoseAmount = Constants.DEFAULT_DEPOSIT_LOSE_POINTS // This is a positive value representing amount to lose


       return when (condition) {
           StudyPhase.INTERVENTION_CONTROL -> if (goalReached) controlEarn else Constants.DEFAULT_CONTROL_LOSE_POINTS // Usually 0 for control loss
           StudyPhase.INTERVENTION_DEPOSIT -> if (goalReached) depositEarn else -depositLoseAmount // Subtract the positive lose amount
           StudyPhase.INTERVENTION_FLEXIBLE -> {
               // Use fetched values, assuming validation passed in doWork
               // Default to min constants if somehow null (should not happen due to validation)
               val earnPoints = flexEarn ?: Constants.FLEX_STAKES_MIN_EARN
               val losePoints = flexLose ?: Constants.FLEX_STAKES_MIN_LOSE
               if (goalReached) earnPoints else -losePoints // Subtract the positive lose amount
           }
           else -> {
               Log.w(TAG, "Calculating points change for unexpected phase: $condition. Returning 0.")
               0
           }
       }
   }


   /**
    * Updates pointsBalance field in the user's Firestore document.
    */
   private suspend fun updatePointsInFirestore(userId: String, newPoints: Int) {
       try {
           val firestore = Firebase.firestore
           // Use constants for collection and field names
           firestore.collection(Constants.FIRESTORE_COLLECTION_USERS).document(userId)
               .update(Constants.FIRESTORE_FIELD_POINTS_BALANCE, newPoints.toLong()) // Firestore typically uses Long for numbers
               .await() // Wait for completion
           Log.i(TAG,"Successfully updated pointsBalance to $newPoints in Firestore for user $userId")
       } catch(e: Exception) {
           Log.e(TAG, "Failed to update pointsBalance in Firestore for user $userId", e)
           // Consider re-throwing or handling more specifically if needed, currently logged only
       }
   }
}


</DailyCheckWorker>






<FirestoreSyncWorker>
package com.niyaz.zario.workers


import android.content.Context
import android.util.Log
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.NetworkType
import androidx.work.WorkerParameters
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.data.local.AppDatabase
import com.niyaz.zario.data.local.UsageStatDao
import com.niyaz.zario.data.local.UsageStatEntity
import com.niyaz.zario.utils.Constants
import com.niyaz.zario.utils.StudyStateManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale


class FirestoreSyncWorker(appContext: Context, workerParams: WorkerParameters) :
   CoroutineWorker(appContext, workerParams) {


   companion object {
       private const val TAG = "FirestoreSyncWorker"
       // Unique Name for the Worker
       const val UNIQUE_WORK_NAME = "ZarioFirestoreSync"
       // Configuration for the worker constraints
       val WORKER_CONSTRAINTS = Constraints.Builder()
           .setRequiredNetworkType(NetworkType.CONNECTED) // Only run when connected
           .build()
       // How often to run the sync (e.g., every 6 hours)
       val REPEAT_INTERVAL_HOURS = 1L
       // Batch size for processing local records
       const val BATCH_SIZE = 100
   }


   // Get dependencies (DAO, Firestore, StateManager)
   private val usageStatDao: UsageStatDao = AppDatabase.getDatabase(appContext).usageStatDao()
   private val firestore: FirebaseFirestore = Firebase.firestore


   override suspend fun doWork(): Result {
       Log.d(TAG, "Worker starting...")


       val userId = StudyStateManager.getUserId(applicationContext)
       if (userId == null) {
           Log.e(TAG, "User ID not found. Cannot sync data. Stopping worker.")
           // Returning success because the condition preventing work isn't transient
           // We don't want it to keep retrying if the user isn't logged in.
           return Result.success()
       }


       Log.i(TAG, "Starting sync process for user: $userId")


       return withContext(Dispatchers.IO) {
           try {
               var recordsProcessed = 0
               var batchCount = 0
               var hasMoreData = true


               // Loop to process data in batches
               while (hasMoreData) {
                   batchCount++
                   Log.d(TAG, "Processing batch #$batchCount for user $userId")
                   val unsyncedStats = usageStatDao.getUnsyncedUsageStats(userId, BATCH_SIZE)


                   if (unsyncedStats.isEmpty()) {
                       Log.d(TAG, "No more unsynced records found for user $userId.")
                       hasMoreData = false
                       continue // Exit loop
                   }


                   Log.d(TAG, "Found ${unsyncedStats.size} unsynced records in batch #$batchCount.")


                   // Aggregate data by Day -> Package -> Duration
                   val dailyAggregations = aggregateDailyUsage(unsyncedStats)


                   // Upload aggregated data to Firestore
                   val uploadSuccess = uploadAggregatedData(userId, dailyAggregations)


                   if (uploadSuccess) {
                       // Mark local records as synced ONLY if upload was successful
                       val idsToMarkSynced = unsyncedStats.map { it.id }
                       usageStatDao.markUsageStatsAsSynced(idsToMarkSynced)
                       recordsProcessed += unsyncedStats.size
                       Log.i(TAG, "Batch #$batchCount successfully synced. Marked ${idsToMarkSynced.size} records.")
                   } else {
                       Log.e(TAG, "Failed to upload batch #$batchCount to Firestore. Will retry later.")
                       // Stop processing further batches in this run and trigger retry
                       return@withContext Result.retry()
                   }


                   // Check if we fetched less than the batch size, indicating end of data
                   if (unsyncedStats.size < BATCH_SIZE) {
                       hasMoreData = false
                   }
               } // End while loop


               Log.i(TAG, "Sync process finished for user $userId. Total records processed in this run: $recordsProcessed.")
               Result.success()


           } catch (e: Exception) {
               Log.e(TAG, "Error during sync process for user $userId", e)
               Result.retry() // Retry on failure
           }
       } // End withContext
   }


   /**
    * Aggregates a list of raw UsageStatEntity records into a map suitable for Firestore.
    * Structure: Map<"YYYY-MM-DD", Map<"packageName", totalDurationMs>>
    */
   private fun aggregateDailyUsage(stats: List<UsageStatEntity>): Map<String, Map<String, Long>> {
       // Use SimpleDateFormat for date formatting (consider thread safety if needed, but fine within worker)
       val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.US)
       // Structure: Map<"YYYY-MM-DD", MutableMap<"packageName", totalDurationMs>>
       val dailyMap = mutableMapOf<String, MutableMap<String, Long>>()


       stats.forEach { stat ->
           // dayTimestamp is the start of the day in millis
           val dateString = dateFormat.format(Date(stat.dayTimestamp))
           val packageMap = dailyMap.getOrPut(dateString) { mutableMapOf() }
           packageMap[stat.packageName] = packageMap.getOrDefault(stat.packageName, 0L) + stat.durationMs
       }
       return dailyMap
   }


   /**
    * Uploads aggregated daily usage data to Firestore for a specific user.
    * Uses batched writes or individual document updates with merge options.
    */
   private suspend fun uploadAggregatedData(userId: String, dailyData: Map<String, Map<String, Long>>): Boolean {
       if (dailyData.isEmpty()) return true // Nothing to upload


       Log.d(TAG, "Uploading ${dailyData.size} days of aggregated data to Firestore for user $userId.")


       try {
           // Use Firestore Batched Write for efficiency
           val batch = firestore.batch()


           dailyData.forEach { (dateString, packageData) ->
               // Document path: /users/{userId}/daily_app_usage/{YYYY-MM-DD}
               val dateDocRef = firestore.collection(Constants.FIRESTORE_COLLECTION_USERS)
                   .document(userId)
                   .collection("daily_app_usage") // Subcollection for daily usage
                   .document(dateString)


               // Prepare data for update: Use FieldValue.increment to add durations atomically
               val updates = packageData.mapValues { FieldValue.increment(it.value) }


               // Set with merge=true adds new fields or increments existing ones
               batch.set(dateDocRef, updates, SetOptions.merge())
           }


           // Commit the batch
           batch.commit().await()
           Log.d(TAG, "Firestore batch commit successful for user $userId.")
           return true
       } catch (e: Exception) {
           Log.e(TAG, "Firestore batch commit failed for user $userId", e)
           return false
       }
   }
}


</FirestoreSyncWorker>




<MainActivity>
package com.niyaz.zario


import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.ktx.auth
import com.google.firebase.ktx.Firebase
import com.niyaz.zario.navigation.Screen
import com.niyaz.zario.ui.screens.AuthDecisionScreen
import com.niyaz.zario.ui.screens.HomeScreen
import com.niyaz.zario.ui.screens.LoginScreen
import com.niyaz.zario.ui.screens.RegisterScreen
import com.niyaz.zario.ui.theme.ZarioTheme
import com.niyaz.zario.utils.StudyStateManager


class MainActivity : ComponentActivity() {


   private lateinit var auth: FirebaseAuth // Declare FirebaseAuth instance


   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       auth = Firebase.auth // Initialize FirebaseAuth


       // --- Determine Start Destination ---
       val startDestination = if (auth.currentUser != null) {
           // User is logged in, but also check if study state is valid (e.g., wasn't cleared unexpectedly)
           // If user exists but local state is cleared, log them out for safety.
           if (StudyStateManager.getUserId(this) == null) {
               auth.signOut() // Sign out if local state missing despite auth user
               Screen.AuthDecision.route // Go to login/register
           } else {
               Screen.Home.route // Go directly to home
           }
       } else {
           Screen.AuthDecision.route // No user, go to login/register
       }
       // --- End Start Destination Logic ---


       setContent {
           ZarioTheme {
               Surface(
                   modifier = Modifier.fillMaxSize(),
                   color = MaterialTheme.colorScheme.background
               ) {
                   // Pass the determined start destination
                   AppNavigation(startDestination = startDestination)
               }
           }
       }
   }
}


@Composable
// Modify AppNavigation to accept startDestination
fun AppNavigation(startDestination: String) {
   // Creates a NavController instance, remembers it across recompositions
   val navController = rememberNavController()


   // NavHost defines the navigation graph
   NavHost(
       navController = navController,
       // Set the starting screen dynamically
       startDestination = startDestination
   ) {
       // Define each screen (composable) linked to a route (no changes needed here)
       composable(route = Screen.AuthDecision.route) {
           AuthDecisionScreen(navController = navController)
       }
       composable(route = Screen.Login.route) {
           LoginScreen(navController = navController)
       }
       composable(route = Screen.Register.route) {
           RegisterScreen(navController = navController)
       }
       composable(route = Screen.Home.route) {
           HomeScreen(navController = navController)
       }
       // Add routes for other screens if/when they are created (e.g., AnalyticsScreen)
       // composable(route = Screen.Analytics.route) { // Example placeholder
       //    AnalyticsScreen(navController = navController)
       // }
   }
}


</MainActivity>




<strings>
<?xml version="1.0" encoding="utf-8"?>
<resources>
   <!-- Generally used strings -->
   <string name="app_name">Zario Study</string> <!-- Updated App Name -->
   <string name="back">Back</string>
   <string name="cancel">Cancel</string>
   <string name="error_generic_label">Error</string>
   <string name="error_generic_message">An unexpected error occurred. Please try again later.</string>
   <string name="email_address_label">Email Address</string>
   <string name="password_label">Password</string>
   <string name="validation_invalid_email">Invalid Email Address</string>
   <string name="validation_password_empty">Password cannot be empty</string>
   <string name="points_unit">points</string> <!-- For use in formatted strings -->


   <!-- AuthDecision Screen -->
   <string name="auth_decision_welcome">Welcome to Zario Study App</string>
   <string name="auth_decision_login_button">Login</string>
   <string name="auth_decision_register_button">Register</string>


   <!-- Login Screen -->
   <string name="login_title">Log In</string>
   <string name="login_forgot_password_button">Forgot Password?</string>
   <string name="login_error_invalid_credentials">Login failed: Invalid email or password.</string>
   <string name="login_error_session_verification">Login failed: Could not verify user session.</string>
   <string name="login_error_load_study_data">Login successful, but couldn\'t load study data. Please contact support.</string>
   <string name="login_button">Log In</string>
   <string name="login_reset_dialog_title">Reset Password</string>
   <string name="login_reset_dialog_message">Enter your email address to receive a password reset link.</string>
   <string name="login_reset_dialog_send_button">Send Reset Email</string>
   <string name="login_reset_dialog_toast_success">Password reset email sent.</string>
   <string name="login_reset_dialog_toast_failure">Failed to send reset email. Try again.</string>


   <!-- Register Screen -->
   <string name="register_title">Create Account</string>
   <string name="register_yob_label">Year of Birth (YYYY)</string>
   <string name="register_gender_label">Gender</string>
   <string name="register_confirm_password_label">Confirm Password</string>
   <string name="register_button">Register</string>
   <string name="register_gender_male">Male</string>
   <string name="register_gender_female">Female</string>
   <string name="register_gender_other">Other</string>
   <string name="register_gender_prefer_not_say">Prefer not to say</string>
   <string name="register_validation_invalid_year">Invalid Year</string>
   <string name="register_validation_gender_required">Please select a gender</string>
   <string name="register_validation_password_length">Password must be at least 8 characters</string>
   <string name="register_validation_password_mismatch">Passwords do not match</string>
   <string name="register_error_profile_save">Account created, but failed to save profile data. Please try logging in.</string>
   <string name="register_error_user_id">Registration failed: Could not get user ID.</string>
   <string name="register_error_email_collision">Registration failed: Email address already in use.</string>
   <string name="register_error_generic">Registration failed. Please try again later.</string> <!-- Reuses generic error -->


   <!-- Home Screen & General Study -->
   <string name="home_logout_button">Log Out</string>
   <string name="home_study_phase_label">Study Phase: %1$s</string>
   <string name="home_registered_title">Registration Complete</string>
   <string name="home_registered_message">Waiting to start baseline period.</string>
   <string name="home_registered_refresh_button">Refresh Status</string>
   <string name="home_baseline_title">Baseline Data Collection</string>
   <string name="home_baseline_progress">Day %1$d of %2$d</string>
   <string name="home_baseline_message">Please use your phone normally.\nUsage tracking is active in the background.</string>
   <string name="home_completed_title">Study Completed</string>
   <string name="home_completed_message">Thank you for your participation!</string>
   <string name="home_permission_title">Permissions Required</string>
   <string name="home_permission_notification_message">This app needs permission to show notifications for study updates and warnings.</string>
   <string name="home_permission_notification_button">Grant Notification Permission</string>
   <string name="home_permission_usage_message">This app also needs Usage Access permission to track app usage for the study.</string>
   <string name="home_permission_usage_button">Open Settings for Usage Access</string>
   <string name="home_permission_check_button">Check Permissions Again</string>


   <!-- Goal Setting -->
   <string name="goal_setting_loading_title">Analyzing Baseline Usage...</string>
   <string name="goal_setting_error_title">Error Loading Baseline Data</string>
   <string name="goal_setting_error_message">Please ensure the app had permission during the baseline week and try again.</string>
   <string name="goal_setting_retry_button">Retry</string>
   <string name="goal_setting_saved_title">Goal Saved!</string>
   <string name="goal_setting_title">Set Your Goal</string>
   <string name="goal_setting_suggestion_with_app">Based on your usage last week, your most used app was %1$s. Select an app below to focus on reducing its usage.</string>
   <string name="goal_setting_suggestion_no_app">Select an app below to focus on reducing its usage.</string>
   <string name="goal_setting_selection_title">Which app do you want to reduce time use?</string>
   <string name="goal_setting_app_icon_description">%1$s icon</string>
   <string name="goal_setting_selected_app_info">According to our analysis you use %1$s about %2$s per day.</string>
   <string name="goal_setting_selected_app_goal">Your goal is to decrease your use of this app by 20%% which is %1$s per day.</string> <!-- Escaped % -->
   <string name="goal_setting_select_prompt">Select an app icon above.</string>
   <string name="goal_setting_chart_title">Primary Usage Times (Baseline)</string>
   <string name="goal_setting_chart_empty">No baseline usage data for chart</string>
   <string name="goal_setting_confirm_button">Confirm Goal for %1$s</string>
   <string name="goal_setting_confirm_button_default">Confirm Goal for ...</string>


   <!-- Flexible Deposit Setup -->
   <string name="flex_setup_title">Set Your Daily Stakes</string>
   <string name="flex_setup_message">Choose how many points you want to earn for success or lose for missing your daily goal.</string>
   <string name="flex_setup_earn_label">Points Earned on Success: %1$d</string>
   <string name="flex_setup_lose_label">Points Lost on Failure: %1$d</string>
   <string name="flex_setup_confirm_button">Confirm Stakes</string>


   <!-- Intervention Dashboard -->
   <string name="dashboard_title">Dashboard</string>
   <string name="dashboard_goal_section_title">My Goal</string>
   <string name="dashboard_goal_text">Use %1$s less than\n%2$s / day</string>
   <string name="dashboard_goal_not_set">Goal not set</string>
   <string name="dashboard_points_section_title">Points</string>
   <string name="dashboard_progress_text">%1$s\nleft</string>
   <string name="dashboard_progress_goal_not_set">Daily goal not set</string>
   <string name="dashboard_commitment_section_title">My Daily Commitment</string>
   <string name="dashboard_commitment_control">If I succeed I will earn 10 points,\nIf I fail there is no change.</string>
   <string name="dashboard_commitment_deposit">If I succeed I will earn 10 points,\nIf I fail I will lose 40 points.</string>
   <string name="dashboard_commitment_flex">If I succeed I will earn %1$s points,\nIf I fail I will lose %2$s points.</string>
   <string name="dashboard_commitment_fallback">Commitment information not applicable.</string>


   <!-- Notifications -->
   <string name="notification_channel_name">Zario Study Updates</string>
   <string name="notification_channel_description">Notifications about daily goals and usage.</string>
   <string name="notification_foreground_title">Zario Active</string>
   <string name="notification_foreground_text">Monitoring app usage for your goals.</string>
   <string name="notification_daily_feedback_title">Yesterday\'s Goal Result</string> <!-- Escaped apostrophe -->
   <string name="notification_daily_feedback_success">You reached your goal! You gained %1$d %2$s.</string> <!-- Added points unit -->
   <string name="notification_daily_feedback_fail">You missed your goal. You lost %1$d %2$s.</string> <!-- Added points unit -->
   <string name="notification_daily_feedback_balance_suffix">\nYour current balance is %1$d %2$s.</string> <!-- Added points unit -->
   <string name="notification_warning_90_title">Approaching Daily Limit</string>
   <string name="notification_warning_90_message">You have used %1$d minutes of your %2$d minute daily limit for %3$s. Approximately %4$d minutes remaining.</string>
   <string name="notification_limit_100_title">Daily Limit Reached</string>
   <string name="notification_limit_100_message">You have reached your %1$d minute daily limit for %2$s. Exceeding the limit today will result in %3$s.</string>
   <string name="notification_limit_100_consequence_control">missing the goal (no direct point loss)</string>
   <string name="notification_limit_100_consequence_deposit">losing 40 %1$s</string> <!-- Added points unit -->
   <string name="notification_limit_100_consequence_flex_lose">losing %1$d %2$s</string> <!-- Added points unit -->
   <string name="notification_limit_100_consequence_flex_no_lose">missing the goal (no point loss as per your choice)</string>
   <string name="notification_limit_100_consequence_fallback">missing the goal</string>


</resources>
</strings>






<build.gradle.kts (Project: Zario)>
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
   alias(libs.plugins.android.application) apply false
   alias(libs.plugins.kotlin.android) apply false
   alias(libs.plugins.compose.compiler) apply false // <<< ADD THIS LINE
   alias(libs.plugins.kotlin.devtools.ksp) apply false // <<< ADD THIS LINE
   alias(libs.plugins.google.services) apply false
}


</build.gradle.kts (Project: Zario)>








<build.gradle.kts (Module :app)>
plugins {
   alias(libs.plugins.android.application)
   alias(libs.plugins.kotlin.android)
   alias(libs.plugins.compose.compiler) // <<< ADD THIS LINE
   alias(libs.plugins.kotlin.devtools.ksp) // <<< ADD THIS LINE
   alias(libs.plugins.google.services) // <<< ADD THIS LINE




}


android {
   namespace = "com.niyaz.zario"
   compileSdk = 35 // Keep this as 35


   defaultConfig {
       applicationId = "com.niyaz.zario"
       minSdk = 26 // Minimum SDK required
       targetSdk = 35 // Target SDK should match compileSdk
       versionCode = 1
       versionName = "1.0"


       testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
       // Vector Drawables are generally preferred
       vectorDrawables {
           useSupportLibrary = true
       }
   }


   buildTypes {
       release {
           isMinifyEnabled = false // Keep false for now during development
           proguardFiles(
               getDefaultProguardFile("proguard-android-optimize.txt"),
               "proguard-rules.pro"
           )
       }
   }
   compileOptions {
       sourceCompatibility = JavaVersion.VERSION_11
       targetCompatibility = JavaVersion.VERSION_11
   }
   kotlinOptions {
       jvmTarget = "11"
   }
   // Enable Compose features
   buildFeatures {
       compose = true
   }


   // Packaging options often needed for Compose
   packaging {
       resources {
           excludes += "/META-INF/{AL2.0,LGPL2.1}"
       }
   }
}


dependencies {


   implementation(libs.androidx.core.ktx)
   // Lifecycle dependency needed by Compose Activity
   implementation(libs.androidx.lifecycle.runtime.ktx)


   // --- Jetpack Compose Dependencies ---
   // Integration with Activities
   implementation(libs.androidx.activity.compose)
   // Core Compose UI elements
   implementation(platform(libs.androidx.compose.bom)) // Import the Compose BOM
   implementation(libs.androidx.compose.ui)
   implementation(libs.androidx.compose.ui.graphics)
   // Compose Tooling support (Previews)
   implementation(libs.androidx.compose.ui.tooling.preview)
   debugImplementation(libs.androidx.compose.ui.tooling) // Tooling needed for inspection in debug builds
   // Compose Material 3 Design
   implementation(libs.androidx.compose.material3)
   // Compose Navigation (for moving between screens)
   implementation(libs.androidx.navigation.compose)
   // Compose ViewModel integration (for state management)
   implementation(libs.androidx.lifecycle.viewmodel.compose)
   // --- End Jetpack Compose Dependencies ---


   // ViewModel Compose Integration
   implementation(libs.androidx.lifecycle.viewmodel.compose) // Already added earlier, ensure it's correct alias


   implementation(libs.androidx.work.runtime.ktx) // Add WorkManager
   implementation(libs.coil.compose)


   // --- Firebase ---
   // Import the BoM for version management
   implementation(platform(libs.firebase.bom))
   // Add Analytics (Recommended by Firebase, useful for basic event tracking)
   implementation("com.google.firebase:firebase-analytics-ktx") // Or use alias if defined
   // Add Firebase Authentication library
   implementation(libs.firebase.auth.ktx)
   // Add Cloud Firestore library
   implementation(libs.firebase.firestore.ktx)
   // --- End Firebase ---


   // --- Room Persistence ---
   implementation(libs.androidx.room.runtime)
   implementation(libs.androidx.room.ktx) // Include Coroutines support
   // Annotation processor using KSP
   ksp(libs.androidx.room.compiler) // Use ksp() instead of annotationProcessor()
   // --- End Room Persistence ---


   // Remove AppCompat if you are fully migrating to Compose for UI
   // implementation(libs.androidx.appcompat) // Commented out/Removed
   // Remove old Material Components if using Material 3 Compose
   // implementation(libs.material) // Commented out/Removed


   // --- Testing Dependencies ---
   testImplementation(libs.junit)
   androidTestImplementation(libs.androidx.junit)
   androidTestImplementation(libs.androidx.espresso.core)
   // AndroidJUnit4 Runner is needed for instrumented tests with Compose
   androidTestImplementation(libs.androidx.runner)
   // Compose UI Testing specific dependencies
   androidTestImplementation(platform(libs.androidx.compose.bom)) // Use BOM for testing too
   androidTestImplementation(libs.androidx.compose.ui.test.junit4)
   debugImplementation(libs.androidx.compose.ui.test.manifest) // Manifest for testing






}


</build.gradle.kts (Module :app)>




<libs.versions.toml>
[versions]
# Build Tools & Core
agp = "8.9.1" # Android Gradle Plugin
kotlin = "2.0.21" # Kotlin Plugin (Used for compose compiler plugin version too)
coreKtx = "1.13.1"
room = "2.6.1"




# Lifecycle (ViewModel, Runtime)
lifecycle = "2.8.3"


# Compose
activityCompose = "1.9.1"
composeBom = "2024.06.00"
# composeCompiler = "1.5.14" # REMOVED - No longer needed here
navigationCompose = "2.7.7"


# Testing
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
androidTestRunner = "1.6.1"


googleServicesPlugin = "4.4.2"
firebaseBom = "33.12.0"
workManager = "2.10.0"


coil = "2.6.0"




[libraries]
# Core & Lifecycle
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycle" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycle" }


# Compose BOM (Bill of Materials)
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }


# Compose UI Components (Versions managed by BOM)
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-compose-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-compose-material3 = { group = "androidx.compose.material3", name = "material3" }


# --- Room Persistence ---
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "room" }
# Optional: Kotlin Extensions and Coroutines support for Room
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "room" }
# Optional: Room testing helpers
# androidx-room-testing = { group = "androidx.room", name = "room-testing", version.ref = "room" }


# Compose Navigation
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationCompose" }


# Testing
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit-ktx", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-runner = { group = "androidx.test", name = "runner", version.ref = "androidTestRunner" }
# Compose Testing (Versions managed by BOM)
androidx-compose-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-compose-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }


# --- Firebase ---
firebase-bom = { group = "com.google.firebase", name = "firebase-bom", version.ref = "firebaseBom" }
firebase-auth-ktx = { group = "com.google.firebase", name = "firebase-auth-ktx" }
firebase-firestore-ktx = { group = "com.google.firebase", name = "firebase-firestore-ktx" }
androidx-work-runtime-ktx = { group = "androidx.work", name = "work-runtime-ktx", version.ref = "workManager" }


# *** CORRECT PLACEMENT FOR COIL LIBRARY ***
coil-compose = { group = "io.coil-kt", name = "coil-compose", version.ref = "coil" }


[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
# ADDED Compose Compiler Plugin - Uses the same version as Kotlin itself
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
kotlin-devtools-ksp = { id = "com.google.devtools.ksp", version = "2.0.21-1.0.25" }
google-services = { id = "com.google.gms.google-services", version.ref = "googleServicesPlugin" }


</libs.versions.toml>